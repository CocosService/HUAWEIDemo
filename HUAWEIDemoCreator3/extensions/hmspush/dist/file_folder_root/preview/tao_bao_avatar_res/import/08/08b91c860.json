[1,["afzNXuNVBC5r5x5UZ5vyWu"],["_effectAsset"],[["cc.Material",["_name","_props","_states","_defines"],-1],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,3,5],[1,0,1,2,4]],[[[[0,"car",[{},{},{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}]]],0,0,[0],[0],[0]],[[[1,"../sdk/res/mat/car",[{"hash":191907094,"name":"../sdk/res/mat/car|car-vs:vert|car-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"u_detail_normal_map_st","type":16,"count":1},{"name":"u_specular_color","type":16,"count":1},{"name":"u_tintcolor_base","type":16,"count":1},{"name":"u_tintcolor_high","type":16,"count":1},{"name":"u_tintcolor_mid","type":16,"count":1},{"name":"u_tintcolor_low","type":16,"count":1},{"name":"u_rim_color","type":16,"count":1},{"name":"u_wave_map_st","type":16,"count":1},{"name":"u_flicker_color","type":16,"count":1},{"name":"u_TilingOffset","type":16,"count":1},{"name":"u_s_adjust","type":13,"count":1},{"name":"u_v_adjust","type":13,"count":1},{"name":"u_ao_intense","type":13,"count":1},{"name":"u_ao_s_adjust","type":13,"count":1},{"name":"u_detail_normal_scale","type":13,"count":1},{"name":"u_metallic","type":13,"count":1},{"name":"u_glossness","type":13,"count":1},{"name":"u_bloodValue","type":13,"count":1},{"name":"u_diffuseRampToon_v","type":13,"count":1},{"name":"u_diffuseRampToon_u_high","type":13,"count":1},{"name":"u_diffuseRampToon_u_mid","type":13,"count":1},{"name":"u_diffuseRampToon_u_low","type":13,"count":1},{"name":"u_anisotropic_nvAmd","type":13,"count":1},{"name":"u_gmes_controlR","type":13,"count":1},{"name":"u_rim_power","type":13,"count":1},{"name":"u_candyNv_range","type":13,"count":1},{"name":"u_candy_intensity","type":13,"count":1},{"name":"u_Time","type":13,"count":1},{"name":"u_waveAlpha","type":13,"count":1},{"name":"u_waveSpeedX","type":13,"count":1},{"name":"u_waveSpeedY","type":13,"count":1},{"name":"u_flickerSpeed","type":13,"count":1},{"name":"u_miplv_offset","type":13,"count":1},{"name":"u_m_factor","type":13,"count":1},{"name":"u_clip_threshold","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"u_albedo_map","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]},{"name":"u_ao_map","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["_USEAOMAP_ON"]},{"name":"u_normal_map","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["_USENORMALMAP_ON"]},{"name":"u_detail_normal_map","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["_USEDETAILNORMALMAP_ON"]},{"name":"u_metallic_map","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["_USEMETALLICMAP_ON"]},{"name":"u_sss_map","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["_USESSSMAP_ON"]},{"name":"u_specular_map","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["_USESPECULARMAP_ON"]},{"name":"u_diffuseRamp_map","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["_USEDIFFUSERAMPMAP_ON"]},{"name":"u_indirect_diffuse_map","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["_USEINDIRECTDIFFUSEMAP_ON"]},{"name":"u_indirect_specular_map","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["_USEINDIRECTSPECULARMAP_ON"]},{"name":"u_anisotropic_map","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["_USEANISOTROPICMAP_ON"]},{"name":"u_wave_map","type":28,"count":1,"stageFlags":16,"binding":12,"defines":["_TOGGLEWAVE_ON","_USEWAVEMAP_ON"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":15,"defines":["CC_USE_MORPH"]},{"name":"a_Color","format":44,"location":16,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"u_detail_normal_map_st","type":16,"count":1},{"name":"u_specular_color","type":16,"count":1},{"name":"u_tintcolor_base","type":16,"count":1},{"name":"u_tintcolor_high","type":16,"count":1},{"name":"u_tintcolor_mid","type":16,"count":1},{"name":"u_tintcolor_low","type":16,"count":1},{"name":"u_rim_color","type":16,"count":1},{"name":"u_wave_map_st","type":16,"count":1},{"name":"u_flicker_color","type":16,"count":1},{"name":"u_TilingOffset","type":16,"count":1},{"name":"u_s_adjust","type":13,"count":1},{"name":"u_v_adjust","type":13,"count":1},{"name":"u_ao_intense","type":13,"count":1},{"name":"u_ao_s_adjust","type":13,"count":1},{"name":"u_detail_normal_scale","type":13,"count":1},{"name":"u_metallic","type":13,"count":1},{"name":"u_glossness","type":13,"count":1},{"name":"u_bloodValue","type":13,"count":1},{"name":"u_diffuseRampToon_v","type":13,"count":1},{"name":"u_diffuseRampToon_u_high","type":13,"count":1},{"name":"u_diffuseRampToon_u_mid","type":13,"count":1},{"name":"u_diffuseRampToon_u_low","type":13,"count":1},{"name":"u_anisotropic_nvAmd","type":13,"count":1},{"name":"u_gmes_controlR","type":13,"count":1},{"name":"u_rim_power","type":13,"count":1},{"name":"u_candyNv_range","type":13,"count":1},{"name":"u_candy_intensity","type":13,"count":1},{"name":"u_Time","type":13,"count":1},{"name":"u_waveAlpha","type":13,"count":1},{"name":"u_waveSpeedX","type":13,"count":1},{"name":"u_waveSpeedY","type":13,"count":1},{"name":"u_flickerSpeed","type":13,"count":1},{"name":"u_miplv_offset","type":13,"count":1},{"name":"u_m_factor","type":13,"count":1},{"name":"u_clip_threshold","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"u_albedo_map","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]},{"name":"u_ao_map","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["_USEAOMAP_ON"]},{"name":"u_normal_map","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["_USENORMALMAP_ON"]},{"name":"u_detail_normal_map","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["_USEDETAILNORMALMAP_ON"]},{"name":"u_metallic_map","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["_USEMETALLICMAP_ON"]},{"name":"u_sss_map","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["_USESSSMAP_ON"]},{"name":"u_specular_map","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["_USESPECULARMAP_ON"]},{"name":"u_diffuseRamp_map","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["_USEDIFFUSERAMPMAP_ON"]},{"name":"u_indirect_diffuse_map","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["_USEINDIRECTDIFFUSEMAP_ON"]},{"name":"u_indirect_specular_map","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["_USEINDIRECTSPECULARMAP_ON"]},{"name":"u_anisotropic_map","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["_USEANISOTROPICMAP_ON"]},{"name":"u_wave_map","type":28,"count":1,"stageFlags":16,"binding":12,"defines":["_TOGGLEWAVE_ON","_USEWAVEMAP_ON"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_1","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_2","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_3","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":1,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 u_detail_normal_map_st;\n  vec4 u_specular_color;\n   vec4 u_tintcolor_base;\n   vec4 u_tintcolor_high;\n   vec4 u_tintcolor_mid;\n   vec4 u_tintcolor_low;\n   vec4 u_rim_color;\n   vec4 u_wave_map_st;\n    vec4 u_flicker_color;\n    vec4 u_TilingOffset;\n   float u_s_adjust;\n   float u_v_adjust;\n   float u_ao_intense;\n   float u_ao_s_adjust;\n  float u_detail_normal_scale;\n   float u_metallic;\n   float u_glossness;\n   float u_bloodValue;\n   float u_diffuseRampToon_v;\n   float u_diffuseRampToon_u_high;\n   float u_diffuseRampToon_u_mid;\n   float u_diffuseRampToon_u_low;\n   float u_anisotropic_nvAmd;\n   float u_gmes_controlR;\n   float u_rim_power;\n   float u_candyNv_range;\n   float u_candy_intensity;\n   float u_Time;\n   float u_waveAlpha;\n   float u_waveSpeedX;\n   float u_waveSpeedY;\n   float u_flickerSpeed;\n   float u_miplv_offset;\n   float u_m_factor;\n   float u_clip_threshold;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nmat4 matWorld;\nmat4 matWorldIT;\nvec4 TransformObjectToWorld(vec4 localPos)\n{\n    vec4 wsPos = matWorld * localPos;\n    return wsPos;\n}\nvec4 TransformWorldToHClip(vec4 wsPos)\n{\n    return cc_matViewProj* wsPos;\n}\nvec3 TransformObjectToWorldDir(vec3 localDir)\n{\n    vec3 wsDir = normalize((matWorld * vec4(localDir, 0.0)).xyz);\n    return wsDir;\n}\nvec3 TransformObjectToWorldNormal(vec3 localNormal)\n{\n    vec3 wsNormal = normalize((matWorldIT * vec4(localNormal, 0.0)).xyz);\n    return wsNormal;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n#endif\nuniform samplerCube cc_diffuseMap;\nconst mediump vec4 cc_SHAr = vec4(-0.01268705,-0.002278538,0.02414897,0.1786896);\nconst mediump vec4 cc_SHAg = vec4(-0.008147277,0.01512196,0.02444779,0.1843932);\nconst mediump vec4 cc_SHAb = vec4(-0.001304806,0.0561939,0.02300789,0.1846258);\nconst mediump vec4 cc_SHBr = vec4(0.02138082,-0.004660343,0.002285965,0.002274255);\nconst mediump vec4 cc_SHBg = vec4(0.02184102,-0.004798608,0.006421056,0.000962665);\nconst mediump vec4 cc_SHBb = vec4(0.02326559,-0.005804826,0.01288106,0.0002991784);\nconst mediump vec4 cc_SHC = vec4(-0.0005003031,-0.004637909,-0.0008901492,1);\n#if CC_RECEIVE_SHADOW\n            #endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    out vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n      v_luv.z = cc_lightingMapUVParam.w;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n      v_luv.z = a_lightingMapUVParam.w;\n    #endif\n    }\n#endif\nin vec4 a_Color;\nout lowp vec4 v_Color;\nout vec2 v_Texcoord0;\nout mediump vec3 v_worldPos;\nout mediump vec3 v_viewDir;\nout mediump vec4 v_Tangent;\nout mediump vec4 v_Normal;\nout mediump vec4 v_Binormal;\n#if CC_RECEIVE_SHADOW\n    out mediump vec2 v_shadowBias;\n#endif\nvec4 carLitVert()\n{\n    StandardVertInput In; CCVertInput(In); CCGetWorldMatrixFull(matWorld, matWorldIT);\n    vec4 wsPos=TransformObjectToWorld(In.position);\n    v_worldPos = wsPos.xyz;\n    v_Normal.xyz=TransformObjectToWorldNormal(In.normal);\n    v_Tangent.xyz=TransformObjectToWorldDir(In.tangent.xyz);\n    v_Binormal.xyz=cross(v_Normal.xyz,v_Tangent.xyz)*In.tangent.w;\n    v_Texcoord0 = a_texCoord * u_TilingOffset.xy + u_TilingOffset.zw;\n    v_viewDir = cc_cameraPos.xyz - v_worldPos;\n    #if COLOR && ENABLEVERTEXCOLOR\n        v_Color = a_Color;\n    #endif\n    #if CC_RECEIVE_SHADOW\n      v_shadowBias = CCGetShadowBias();\n    #endif\n    #if SAMPLE_FROM_RT\n      v_Texcoord0 = cc_cameraPos.w > 1.0 ? vec2(v_Texcoord0.x, 1.0 - v_Texcoord0.y) : v_Texcoord0;\n    #endif\n    CC_TRANSFER_FOG(wsPos);\n    v_shadowPos = cc_matLightViewProj * wsPos;\n    #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n      CCLightingMapCaclUV();\n    #endif\n    return TransformWorldToHClip(wsPos);\n}\nvec4 vert ()\n{\n  return carLitVert();\n}\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n  layout(std140) uniform Constants {\n    vec4 u_detail_normal_map_st;\n    vec4 u_specular_color;\n     vec4 u_tintcolor_base;\n     vec4 u_tintcolor_high;\n     vec4 u_tintcolor_mid;\n     vec4 u_tintcolor_low;\n     vec4 u_rim_color;\n     vec4 u_wave_map_st;\n      vec4 u_flicker_color;\n      vec4 u_TilingOffset;\n     float u_s_adjust;\n     float u_v_adjust;\n     float u_ao_intense;\n     float u_ao_s_adjust;\n    float u_detail_normal_scale;\n     float u_metallic;\n     float u_glossness;\n     float u_bloodValue;\n     float u_diffuseRampToon_v;\n     float u_diffuseRampToon_u_high;\n     float u_diffuseRampToon_u_mid;\n     float u_diffuseRampToon_u_low;\n     float u_anisotropic_nvAmd;\n     float u_gmes_controlR;\n     float u_rim_power;\n     float u_candyNv_range;\n     float u_candy_intensity;\n     float u_Time;\n     float u_waveAlpha;\n     float u_waveSpeedX;\n     float u_waveSpeedY;\n     float u_flickerSpeed;\n     float u_miplv_offset;\n     float u_m_factor;\n     float u_clip_threshold;\n  };\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n    mediump vec4 cc_debug_view_mode;\n    mediump vec4 cc_debug_view_composite_pack_1;\n    mediump vec4 cc_debug_view_composite_pack_2;\n    mediump vec4 cc_debug_view_composite_pack_3;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_surfaceTransform;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(std140) uniform CCShadow {\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    mediump vec4 cc_shadowNFLSInfo;\n    mediump vec4 cc_shadowWHPBInfo;\n    mediump vec4 cc_shadowLPNNInfo;\n    lowp vec4 cc_shadowColor;\n    mediump vec4 cc_planarNDInfo;\n  };\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    layout(std140) uniform CCCSM {\n      highp vec4 cc_csmViewDir0[4];\n      highp vec4 cc_csmViewDir1[4];\n      highp vec4 cc_csmViewDir2[4];\n      highp vec4 cc_csmAtlas[4];\n      highp mat4 cc_matCSMViewProj[4];\n      highp vec4 cc_csmProjDepthInfo[4];\n      highp vec4 cc_csmProjInfo[4];\n      highp vec4 cc_csmSplitsInfo;\n    };\n  #endif\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n      #define LIGHT_MAP_TYPE_DISABLED 0\n  #define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n  #define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n  #define REFLECTION_PROBE_TYPE_NONE 0\n  #define REFLECTION_PROBE_TYPE_CUBE 1\n  #define REFLECTION_PROBE_TYPE_PLANAR 2\n  #define LIGHT_TYPE_DIRECTIONAL 0.0\n  #define LIGHT_TYPE_SPHERE 1.0\n  #define LIGHT_TYPE_SPOT 2.0\n  #define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n  #define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n  #define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotShadowMap;\n    #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    #else\n    #endif\n  #endif\n  in highp vec4 v_shadowPos;\n    #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n  #endif\n  #if CC_USE_FOG != 4\n  #endif\n  #if !CC_USE_ACCURATE_FOG\n  in mediump float v_fog_factor;\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n      in vec3 v_luv;\n      uniform sampler2D cc_lightingMap;\n  #endif\n  in lowp vec4 v_Color;\n  in vec2 v_Texcoord0;\n  in vec3 v_worldPos;\n  in mediump vec3 v_viewDir;\n  in mediump vec4 v_Normal;\n  in mediump vec4 v_Tangent;\n  in mediump vec4 v_Binormal;\n  #if CC_RECEIVE_SHADOW\n      in mediump vec2 v_shadowBias;\n  #endif\n  uniform sampler2D u_albedo_map;\n  #if _USEAOMAP_ON\n    uniform sampler2D u_ao_map;\n  #endif\n#if _USENORMALMAP_ON\n  uniform sampler2D u_normal_map;\n#endif\n#if _USEDETAILNORMALMAP_ON\n  uniform sampler2D u_detail_normal_map;\n#endif\n#if _USEMETALLICMAP_ON\n  uniform sampler2D u_metallic_map;\n#endif\n#if _USESSSMAP_ON\n  uniform sampler2D u_sss_map;\n#endif\n#if _USESPECULARMAP_ON\n  uniform sampler2D u_specular_map;\n#endif\n#if _USEDIFFUSERAMPMAP_ON\n  uniform sampler2D u_diffuseRamp_map;\n#endif\n#if _USEINDIRECTDIFFUSEMAP_ON\n  uniform sampler2D u_indirect_diffuse_map;\n#endif\n#if _USEINDIRECTSPECULARMAP_ON\n  uniform sampler2D u_indirect_specular_map;\n#endif\n#if _USEANISOTROPICMAP_ON\n  uniform sampler2D u_anisotropic_map;\n#endif\n#if _TOGGLEWAVE_ON\n  #if _USEWAVEMAP_ON\n    uniform sampler2D u_wave_map;\n  #endif\n#endif\n  float Remap(float inf, float minOld, float maxOld, float minNew, float maxNew)\n  {\n    return minNew + (inf - minOld) * (maxNew - minNew) / (maxOld - minOld);\n  }\n  vec2 CyLindricalUvMap(vec3 direction)\n  {\n    direction = normalize(direction);\n    float x = 0.75 - atan(direction.z, direction.x)/PI/2.0;\n    if(x>1.0)\n    {\n      x = x - 1.0;\n    }\n    return vec2(x, 1.0 - acos(direction.y)/PI);\n  }\n  vec3 Candy(vec3 normal, vec3 blinnPhongHalfVector,vec3 worldSpaceLightDir)\n  {\n    #if _USEANISOTROPICMAP_ON\n      return texture(u_anisotropic_map,vec2(Remap(dot(blinnPhongHalfVector,normal),-1.0,1.0,u_candyNv_range,1.0-u_candyNv_range), 1.0-Remap(dot(worldSpaceLightDir,normal),-1.0,1.0,u_candyNv_range,1.0-u_candyNv_range))).rgb * u_candy_intensity;\n    #else\n      return vec3(0.0);\n    #endif\n  }\n  vec3 Anisotropic(vec3 normal,vec3 blinnPhongHalfVector,vec3 worldSpaceLightDir,vec3 worldViewDir)\n  {\n    #if _ANISOTROPICOPTION_NONE\n      return vec3(0.0);\n    #endif\n    #if _ANISOTROPICOPTION_FROMNVSDK\n      #if _USEANISOTROPICMAP_ON\n        return texture(u_anisotropic_map, vec2(Remap(dot(blinnPhongHalfVector, normal), -1.0, 1.0, u_anisotropic_nvAmd, 1.0), 1.0 - Remap(dot(worldSpaceLightDir, normal), -1.0, 1.0, u_anisotropic_nvAmd, 1.0))).rgb;\n      #else\n        return vec3(0.0);\n      #endif\n    #endif\n    #if _ANISOTROPICOPTION_AMD\n      #if _USEANISOTROPICMAP_ON\n        return texture(u_anisotropic_map, vec2(Remap(dot(worldSpaceLightDir, v_Tangent.xyz), -1.0, 1.0, u_anisotropic_nvAmd, 1.0), 1.0 - Remap(dot(worldViewDir, v_Tangent.xyz), -1.0, 1.0, u_anisotropic_nvAmd, 1.0))).rgb;\n      #else\n        return vec3(0.0);\n      #endif\n    #endif\n    #if _ANISOTROPICOPTION_GMES1\n      return vec3(exp(-pow(dot( v_Tangent.xyz, blinnPhongHalfVector) * u_gmes_controlR / dot( normal, blinnPhongHalfVector), 2.0)));\n    #endif\n    #if _ANISOTROPICOPTION_RIM\n      return pow(1.0 - clamp(dot( normal, worldViewDir), 0.0, 0.999), u_rim_power) * u_rim_color.rgb;\n    #endif\n    return vec3(0.0);\n  }\n  float MipLevel(float roughness)\n  {\n    return (1.7 - roughness * 0.7) * roughness * 6.0;\n  }\n  vec3 FresnelLerp(vec3 specularColor, float grazingTerm, float nDotV)\n  {\n    return mix(specularColor, vec3(grazingTerm), pow( 1.0 - nDotV, 5.0));\n  }\n  vec3 FresnelTerm(vec3 specularColor, float cosA)\n  {\n    return (vec3(1.0) - specularColor) * pow(1.0 - cosA, 5.0) + specularColor;\n  }\n  float GGXTerm(float nDotH, float roughness)\n  {\n    float a2 = roughness * roughness;\n    float d = (nDotH * a2 - nDotH) * nDotH + 1.0;\n    return ((1.0/PI) * a2)/(d * d + pow(10.0, -7.0));\n  }\n  float SmithJoint(float nDotL,float nDotV,float roughness)\n  {\n    return 0.5/(((nDotL * (1.0 - roughness) + roughness) * nDotV) + (nDotL * (nDotV *(1.0 - roughness) + roughness)));\n  }\n  float DisneyDiffuse(float nDotV,float nDotL,float lDotH,float perceptualRoughness)\n  {\n    float fd90 = lDotH * lDotH * perceptualRoughness * 2.0 + 0.5;\n    return ((fd90 - 1.0) * pow(1.0 - nDotL, 5.0) + 1.0) * ((fd90 - 1.0) * pow(1.0 - nDotV, 5.0) + 1.0);\n  }\n  vec2 HalfLambertOffset(float uOffset, float vOffet,float halfLambert)\n  {\n    return vec2(clamp(uOffset+halfLambert, 0.0, 1.0), vOffet);\n  }\n  vec4 DiffuseRampToon(float halfLambert)\n  {\n    float rampHightChannel = 1.0;\n    #if _USEDIFFUSERAMPMAP_ON\n      vec2 uv_rampHightChannel = HalfLambertOffset(u_diffuseRampToon_u_high, u_diffuseRampToon_v, halfLambert);\n      uv_rampHightChannel = vec2(uv_rampHightChannel.x, uv_rampHightChannel.y);\n      rampHightChannel = texture(u_diffuseRamp_map, uv_rampHightChannel).r;\n    #endif\n    float rampMidChannel = 1.0;\n    #if _USEDIFFUSERAMPMAP_ON\n      vec2 uv_rampMidChannel = HalfLambertOffset(u_diffuseRampToon_u_mid, u_diffuseRampToon_v, halfLambert);\n      uv_rampMidChannel = vec2(uv_rampMidChannel.x, uv_rampMidChannel.y);\n      rampMidChannel = texture(u_diffuseRamp_map, uv_rampMidChannel).g;\n    #endif\n    float rampLowChannel = 1.0;\n    #if _USEDIFFUSERAMPMAP_ON\n      vec2 uv_rampLowChannel = HalfLambertOffset(u_diffuseRampToon_u_low, u_diffuseRampToon_v, halfLambert);\n      uv_rampLowChannel = vec2(uv_rampLowChannel.x, uv_rampLowChannel.y);\n      rampLowChannel = texture(u_diffuseRamp_map, uv_rampLowChannel).b;\n    #endif\n    float tintHighAlpha = u_tintcolor_high.a * rampHightChannel;\n    float tintMidAlpha = u_tintcolor_mid.a * rampMidChannel;\n    float tintLowAlpha = u_tintcolor_low.a * rampLowChannel;\n    vec3 rgb = mix(mix(mix(u_tintcolor_base.rgb, u_tintcolor_high.rgb, tintHighAlpha), u_tintcolor_mid.rgb, tintMidAlpha), u_tintcolor_low.rgb, tintLowAlpha);\n    return vec4(rgb.xyz, tintHighAlpha + tintMidAlpha + tintLowAlpha);\n  }\n  vec3 HSV2RGB_TB(vec3 c)\n  {\n      vec4 k = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n      return c.z * mix(k.xxx, clamp(abs(fract(c.xxx + k.xyz) * 6.0 - k.www) - k.xxx, 0.0, 1.0), c.y);\n  }\n  vec3 RGB2HSV_TB(vec3 c)\n  {\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    k = mix(vec4(c.bg, k.wz), vec4(c.gb, k.xy), step(c.b, c.g));\n    k = mix(vec4(k.xyw, c.r), vec4(c.r, k.yzx), step(k.x, c.r));\n    float d = k.x - min( k.w, k.y );\n    highp float e = 1.0e-10;\n    return vec3( abs(k.z + (k.w - k.y) / (6.0 * d + e)), d / (k.x + e), k.x);\n  }\n  vec3 HVSAO(vec3 c,float ao_s,float ao_r)\n  {\n      c = RGB2HSV_TB(c);\n    return HSV2RGB_TB(vec3(c.x, mix(clamp(c.y + ao_s, 0.0, 1.0), c.y, ao_r), c.z));\n  }\n  vec3 UnitySafeNormalize(vec3 inVec)\n  {\n      return inVec * inversesqrt(max(0.001, dot(inVec, inVec)));\n  }\n  vec3 MatCap(sampler2D inTex,vec3 inNormal)\n  {\n    vec2 matcap = (cc_matView * vec4(inNormal, 0.0)*0.45+0.5).xy;\n    return texture(inTex, vec2(matcap.x, 1.0 - matcap.y)).rgb;\n  }\n  vec2 UVTrans(vec2 uv,float mipLv)\n  {\n    mipLv = floor(mipLv);\n    float x_offset = 0.0;\n    float curSize_x = pow(2.0, 7.0 -mipLv);\n    for(float i = 0.0; i<10.0; ++i)\n    {\n      if(i>=mipLv)break;\n      x_offset = x_offset + pow(2.0, 7.0 - i);\n    }\n    return vec2((x_offset + uv.x * curSize_x)/256.0, uv.y * ((curSize_x/2.0)/64.0));\n  }\n  vec4 MipSample(sampler2D image, vec2 uv, float mipLv)\n  {\n    vec2 uv_floor = UVTrans(uv, floor(mipLv));\n    vec2 uv_ceil = UVTrans(uv, ceil(mipLv));\n    return mix(texture(image, vec2(uv_floor.x,1.0 - uv_floor.y)).rgba, texture(image, vec2(uv_ceil.x,1.0 - uv_ceil.y)).rgba, fract(mipLv));\n  }\n  vec3 UnpackScaleNormal(vec3 normalMapSample, float scale)\n  {\n    vec3 normalT;\n    normalT.x = 2.0 * normalMapSample.x - 1.0;\n    normalT.y = 1.0 - 2.0 * normalMapSample.y;\n    normalT.xy *= scale;\n    normalT.z = 2.0*normalMapSample.z - 1.0;\n    return normalT;\n  }\n  vec3 WorldNormalVector(vec3 packedNormal, vec3 unitNormal, vec3 tangent,vec3 binormal)\n  {\n    vec3 N = normalize(unitNormal);\n    vec3 T = normalize(tangent);\n    vec3 B = normalize(binormal);\n    mat3 TBN = mat3(T, B, N);\n    vec3 bumpedNormal = TBN*packedNormal;\n    return bumpedNormal;\n  }\n  vec3 NormalMapCombine(vec3 n1, vec3 n2)\n  {\n    #if _COMBINEOPTION_UNITYBLENDING\n      mat3 nBasis = mat3(\n        vec3(n1.z, n1.y, -n1.x),\n        vec3(n1.x, n1.z, -n1.y),\n        vec3(n1.x, n1.y,  n1.z));\n      vec3 r = normalize(n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);\n      return r;\n    #endif\n    return n1;\n  }\n  vec3 clampVec3(vec3 temp, float minV,float maxV)\n  {\n      float temp_x = clamp(temp.x,minV,maxV);\n      float temp_y = clamp(temp.y,minV,maxV);\n      float temp_z = clamp(temp.z,minV,maxV);\n      return vec3(temp_x,temp_y,temp_z);\n  }\n  vec4 clampVec4(vec4 temp, float minV,float maxV)\n  {\n      float temp_x = clamp(temp.x,minV,maxV);\n      float temp_y = clamp(temp.y,minV,maxV);\n      float temp_z = clamp(temp.z,minV,maxV);\n    float temp_w = clamp(temp.w,minV,maxV);\n      return vec4(temp_x,temp_y,temp_z,temp_w);\n  }\n  vec4 carLitFrag()\n  {\n    vec3 worldViewDir = UnitySafeNormalize(v_viewDir);\n    vec3 worldSpaceLightDir = UnitySafeNormalize(-cc_mainLitDir.xyz);\n    vec3 normal_final = vec3(0.0);\n    vec3 normal_map_rgb_base = vec3(0.5, 0.5, 1.0);\n    vec3 normal_map_rgb_detail = vec3(0.5, 0.5, 1.0);\n    float normal_b = 0.0;\n    #if _USENORMALMAP_ON\n      normal_map_rgb_base = texture(u_normal_map, v_Texcoord0).rgb;\n      normal_b = normal_map_rgb_base.b;\n      normal_map_rgb_base.b = 1.0;\n    #endif\n    normal_map_rgb_base = UnpackScaleNormal(normal_map_rgb_base, 1.0);\n    #if _USEDETAILNORMALMAP_ON\n      normal_map_rgb_detail = texture(u_detail_normal_map, v_Texcoord0*u_detail_normal_map_st.xy + u_detail_normal_map_st.zw).rgb;\n    #endif\n    normal_map_rgb_detail = UnpackScaleNormal(normal_map_rgb_detail, u_detail_normal_scale);\n    normal_final = NormalMapCombine(normal_map_rgb_base, normal_map_rgb_detail);\n    vec3 worldNormal = UnitySafeNormalize(WorldNormalVector(normal_final,v_Normal.xyz,v_Tangent.xyz,v_Binormal.xyz));\n    #if LINEAR_MODE\n      vec4 unity_color = vec4(0.04, 0.04, 0.04, 0.96);\n    #else\n      vec4 unity_color = vec4(0.22, 0.22, 0.22, 0.78);\n    #endif\n    float ao_r = 1.0;\n    #if _USEAOMAP_ON\n      ao_r = texture(u_ao_map, v_Texcoord0).r;\n    #endif\n    ao_r = mix(1.0, ao_r, u_ao_intense);\n    vec4 albedo_rgba = texture(u_albedo_map, v_Texcoord0);\n    vec3 albedo_rgb = RGB2HSV_TB(albedo_rgba.rgb);\n    albedo_rgb = HVSAO(HSV2RGB_TB(vec3(albedo_rgb.x, clamp(u_s_adjust + albedo_rgb.y, 0.0, 1.0), clamp(u_v_adjust + albedo_rgb.z, 0.0, 1.0))), u_ao_s_adjust, ao_r);\n    albedo_rgb = clampVec3(albedo_rgb,0.0,1.0);\n    vec4 specular_map_rgba = vec4(0.0, 0.0, 0.0, 1.0);\n    #if _USESPECULARMAP_ON\n      specular_map_rgba = texture(u_specular_map, v_Texcoord0);\n    #endif\n    vec3 metallic_rgb = vec3(0.5, 0.5, 0.5);\n    float metallic_a = 1.0;\n    #if _USEMETALLICMAP_ON\n      vec4 metallic_rgba = clampVec4(texture(u_metallic_map, v_Texcoord0).rgba,0.0,1.0);\n      metallic_rgb = metallic_rgba.rgb;\n      metallic_a = metallic_rgba.a;\n    #endif\n    float metallic = 0.0;\n    float gloss = 0.0;\n    float perceptualRoughness = 0.0;\n    float roughness = 0.0;\n    vec3 specularColor = vec3(0.0);\n    float oneMinusReflectivity = 0.0;\n    vec3 diffuseColor = vec3(0.0);\n    #if _TOOGLEPBRPIPELINE_METALLICSIMPLE\n      metallic = u_metallic;\n      gloss = u_glossness;\n      specularColor = mix(unity_color.xyz, albedo_rgb, metallic);\n      oneMinusReflectivity = unity_color.w * (1.0 - metallic);\n      diffuseColor = vec3(oneMinusReflectivity) * albedo_rgb;\n    #endif\n    #if _TOOGLEPBRPIPELINE_METALLICIMAGE\n      metallic = metallic_rgb.r;\n      gloss = metallic_rgb.g;\n      specularColor = mix(unity_color.xyz, albedo_rgb, metallic);\n      oneMinusReflectivity = unity_color.w * (1.0 - metallic);\n      diffuseColor = vec3(oneMinusReflectivity) * albedo_rgb;\n    #endif\n    #if _TOOGLEPBRPIPELINE_SPECULARSIMPLE\n      metallic = 0.0;\n      gloss = u_glossness;\n      specularColor = u_specular_color.rgb;\n      oneMinusReflectivity = 1.0 - max(max(specularColor.x, specularColor.y), specularColor.z);\n      diffuseColor = (vec3(1.0, 1.0, 1.0) - specularColor) * albedo_rgb;\n    #endif\n    #if _TOOGLEPBRPIPELINE_SPECULARIMAGE\n      metallic = 0.0;\n      gloss = specular_map_rgba.a;\n      specularColor = specular_map_rgba.xyz;\n      oneMinusReflectivity = 1.0 - max(max(specularColor.x, specularColor.y), specularColor.z);\n      diffuseColor = (vec3(1.0, 1.0, 1.0) - specularColor) * albedo_rgb;\n    #endif\n    perceptualRoughness = 1.0 - gloss;\n    roughness = max(perceptualRoughness * perceptualRoughness, 0.002);\n    vec3 blinnPhongHalfVector = normalize(worldViewDir + worldSpaceLightDir);\n    float nDotL = clamp(dot(worldNormal, worldSpaceLightDir), 0.0, 1.0);\n    float lDotH = clamp(dot(worldSpaceLightDir, blinnPhongHalfVector), 0.0, 1.0);\n    float nDotV = abs(dot(worldNormal, worldViewDir));\n    vec3 attenColor = vec3(0.7, 0.69,0.67);\n    float halfLambert =  dot(worldNormal, worldSpaceLightDir) *0.5 + 0.5;\n    vec3 bloodColor =vec3(0.0);\n    #if _TOGGLEDIFFUSERAMP_NONE\n      bloodColor = vec3(nDotL);\n    #endif\n    #if _USESSSMAP_ON\n      bloodColor = texture(u_sss_map, vec2(halfLambert, 1.0 - u_bloodValue)).rgb;\n    #endif\n    #if _TOGGLEDIFFUSERAMP_DIFFUSERAMP\n      bloodColor = DiffuseRampToon(halfLambert).xyz;\n    #endif\n    vec3 indirectDiffuse =vec3(0.0);\n    #if _USEINDIRECTDIFFUSEMAP_ON\n      indirectDiffuse = MatCap(u_indirect_diffuse_map, worldNormal) * ao_r;\n    #endif\n    float specular_temp1 = 0.0;\n    if(specularColor != vec3(0.0, 0.0,0.0))\n    {\n      specular_temp1 = 1.0;\n    }\n    #if LINEAR_MODE\n      float surfaceReduction = 1.0 / (roughness * roughness + 1.0);\n    #else\n      float surfaceReduction = 1.0 - roughness * perceptualRoughness * 0.28;\n    #endif\n    vec3 direction = reflect(-worldViewDir,worldNormal);\n    direction = vec3(-direction.x,direction.y,direction.z);\n    direction = normalize(direction);\n    vec2 indirect_specular_uv = CyLindricalUvMap(direction);\n    vec3 indirect_specular_rgb = vec3(0.5);\n    indirect_specular_uv = vec2(indirect_specular_uv.x, indirect_specular_uv.y);\n    #if _USEINDIRECTSPECULARMAP_ON\n      indirect_specular_rgb = MipSample(u_indirect_specular_map, indirect_specular_uv, MipLevel(perceptualRoughness) + u_miplv_offset).rgb;\n    #endif\n    indirect_specular_rgb = indirect_specular_rgb * u_m_factor;\n    vec3 indirectSpecular = FresnelLerp(specularColor, clamp(gloss + (1.0 - oneMinusReflectivity), 0.0, 1.0), nDotV) * surfaceReduction * indirect_specular_rgb;\n    vec3 specular = max(sqrt(max(SmithJoint(nDotL, nDotV, roughness) * GGXTerm(clamp(dot(worldNormal, blinnPhongHalfVector), 0.0, 1.0), roughness) * PI, 0.0001)) * nDotL, 0.0) * specular_temp1 * FresnelTerm(specularColor, lDotH) * attenColor + indirectSpecular;\n    vec3 anisotropicRGB = Anisotropic(worldNormal, blinnPhongHalfVector, worldSpaceLightDir, worldViewDir) * metallic_rgb.b;\n    vec3 wave = vec3(0.0);\n    #if _TOGGLEWAVE_ON\n      #if _USEWAVEMAP_ON\n        vec2 wave_temp1 = v_Texcoord0 * u_wave_map_st.xy + u_wave_map_st.zw;\n        float wave_time = u_Time/10.0;\n        wave_temp1 = wave_temp1 + vec2(wave_time*u_waveSpeedX , wave_time*u_waveSpeedY);\n        wave = texture(u_wave_map, wave_temp1).rgb * normal_b * u_waveAlpha;\n      #endif\n    #endif\n    vec3 flicker = vec3(0.0);\n    #if _TOGGLEFLICKER_ON\n      flicker = u_flicker_color.xyz *  metallic_rgb.b * abs(cos(u_Time * u_flickerSpeed * 4.0 + 3.0));\n    #endif\n    vec3 tempFinalCol = (indirectDiffuse + bloodColor * DisneyDiffuse(nDotV, nDotL, lDotH, perceptualRoughness) * attenColor) * diffuseColor + specular + anisotropicRGB +  wave + flicker;\n    #if _TOOGLECANDY_ON\n      tempFinalCol = mix(tempFinalCol, tempFinalCol * Candy(worldNormal, blinnPhongHalfVector, worldSpaceLightDir), metallic_rgb.b);\n    #endif\n    vec4 finalCol = vec4(0.0);\n      finalCol.rgb = tempFinalCol;\n    #if _ALPHA_ALBEDO\n        finalCol.a = albedo_rgba.a;\n    #else\n      finalCol.a = 1.0;\n    #endif\n    return finalCol;\n  }\n  vec4 frag ()\n  {\n    vec4 outCol= carLitFrag();\n    if(outCol.a < u_clip_threshold){ discard;}\n    #if _CLIP_COLOR\n        if ( outCol.a < 1.01 ) discard;\n    #endif\n    return outCol;\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n   uniform vec4 u_TilingOffset;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nmat4 matWorld;\nmat4 matWorldIT;\nvec4 TransformObjectToWorld(vec4 localPos)\n{\n    vec4 wsPos = matWorld * localPos;\n    return wsPos;\n}\nvec4 TransformWorldToHClip(vec4 wsPos)\n{\n    return cc_matViewProj* wsPos;\n}\nvec3 TransformObjectToWorldDir(vec3 localDir)\n{\n    vec3 wsDir = normalize((matWorld * vec4(localDir, 0.0)).xyz);\n    return wsDir;\n}\nvec3 TransformObjectToWorldNormal(vec3 localNormal)\n{\n    vec3 wsNormal = normalize((matWorldIT * vec4(localNormal, 0.0)).xyz);\n    return wsNormal;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n#endif\nuniform samplerCube cc_diffuseMap;\nconst mediump vec4 cc_SHAr = vec4(-0.01268705,-0.002278538,0.02414897,0.1786896);\nconst mediump vec4 cc_SHAg = vec4(-0.008147277,0.01512196,0.02444779,0.1843932);\nconst mediump vec4 cc_SHAb = vec4(-0.001304806,0.0561939,0.02300789,0.1846258);\nconst mediump vec4 cc_SHBr = vec4(0.02138082,-0.004660343,0.002285965,0.002274255);\nconst mediump vec4 cc_SHBg = vec4(0.02184102,-0.004798608,0.006421056,0.000962665);\nconst mediump vec4 cc_SHBb = vec4(0.02326559,-0.005804826,0.01288106,0.0002991784);\nconst mediump vec4 cc_SHC = vec4(-0.0005003031,-0.004637909,-0.0008901492,1);\n#if CC_RECEIVE_SHADOW\n            #endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    varying vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n      v_luv.z = cc_lightingMapUVParam.w;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n      v_luv.z = a_lightingMapUVParam.w;\n    #endif\n    }\n#endif\nattribute vec4 a_Color;\nvarying lowp vec4 v_Color;\nvarying vec2 v_Texcoord0;\nvarying mediump vec3 v_worldPos;\nvarying mediump vec3 v_viewDir;\nvarying mediump vec4 v_Tangent;\nvarying mediump vec4 v_Normal;\nvarying mediump vec4 v_Binormal;\n#if CC_RECEIVE_SHADOW\n    varying mediump vec2 v_shadowBias;\n#endif\nvec4 carLitVert()\n{\n    StandardVertInput In; CCVertInput(In); CCGetWorldMatrixFull(matWorld, matWorldIT);\n    vec4 wsPos=TransformObjectToWorld(In.position);\n    v_worldPos = wsPos.xyz;\n    v_Normal.xyz=TransformObjectToWorldNormal(In.normal);\n    v_Tangent.xyz=TransformObjectToWorldDir(In.tangent.xyz);\n    v_Binormal.xyz=cross(v_Normal.xyz,v_Tangent.xyz)*In.tangent.w;\n    v_Texcoord0 = a_texCoord * u_TilingOffset.xy + u_TilingOffset.zw;\n    v_viewDir = cc_cameraPos.xyz - v_worldPos;\n    #if COLOR && ENABLEVERTEXCOLOR\n        v_Color = a_Color;\n    #endif\n    #if CC_RECEIVE_SHADOW\n      v_shadowBias = CCGetShadowBias();\n    #endif\n    #if SAMPLE_FROM_RT\n      v_Texcoord0 = cc_cameraPos.w > 1.0 ? vec2(v_Texcoord0.x, 1.0 - v_Texcoord0.y) : v_Texcoord0;\n    #endif\n    CC_TRANSFER_FOG(wsPos);\n    v_shadowPos = cc_matLightViewProj * wsPos;\n    #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n      CCLightingMapCaclUV();\n    #endif\n    return TransformWorldToHClip(wsPos);\n}\nvec4 vert ()\n{\n  return carLitVert();\n}\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n         uniform vec4 u_detail_normal_map_st;\n       uniform vec4 u_specular_color;\n       uniform vec4 u_tintcolor_base;\n       uniform vec4 u_tintcolor_high;\n       uniform vec4 u_tintcolor_mid;\n       uniform vec4 u_tintcolor_low;\n       uniform vec4 u_rim_color;\n       uniform vec4 u_wave_map_st;\n       uniform vec4 u_flicker_color;\n       uniform float u_s_adjust;\n       uniform float u_v_adjust;\n       uniform float u_ao_intense;\n       uniform float u_ao_s_adjust;\n       uniform float u_detail_normal_scale;\n       uniform float u_metallic;\n       uniform float u_glossness;\n       uniform float u_bloodValue;\n       uniform float u_diffuseRampToon_v;\n       uniform float u_diffuseRampToon_u_high;\n       uniform float u_diffuseRampToon_u_mid;\n       uniform float u_diffuseRampToon_u_low;\n       uniform float u_anisotropic_nvAmd;\n       uniform float u_gmes_controlR;\n       uniform float u_rim_power;\n       uniform float u_candyNv_range;\n       uniform float u_candy_intensity;\n       uniform float u_Time;\n       uniform float u_waveAlpha;\n       uniform float u_waveSpeedX;\n       uniform float u_waveSpeedY;\n       uniform float u_flickerSpeed;\n       uniform float u_miplv_offset;\n       uniform float u_m_factor;\n       uniform float u_clip_threshold;\n  uniform highp mat4 cc_matView;\n  uniform mediump vec4 cc_mainLitDir;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    #endif\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n      #define LIGHT_MAP_TYPE_DISABLED 0\n  #define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n  #define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n  #define REFLECTION_PROBE_TYPE_NONE 0\n  #define REFLECTION_PROBE_TYPE_CUBE 1\n  #define REFLECTION_PROBE_TYPE_PLANAR 2\n  #define LIGHT_TYPE_DIRECTIONAL 0.0\n  #define LIGHT_TYPE_SPHERE 1.0\n  #define LIGHT_TYPE_SPOT 2.0\n  #define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n  #define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n  #define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotShadowMap;\n    #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    #else\n    #endif\n  #endif\n  varying highp vec4 v_shadowPos;\n    #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n  #endif\n  #if CC_USE_FOG != 4\n  #endif\n  #if !CC_USE_ACCURATE_FOG\n  varying mediump float v_fog_factor;\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n      varying vec3 v_luv;\n      uniform sampler2D cc_lightingMap;\n  #endif\n  varying lowp vec4 v_Color;\n  varying vec2 v_Texcoord0;\n  varying vec3 v_worldPos;\n  varying mediump vec3 v_viewDir;\n  varying mediump vec4 v_Normal;\n  varying mediump vec4 v_Tangent;\n  varying mediump vec4 v_Binormal;\n  #if CC_RECEIVE_SHADOW\n      varying mediump vec2 v_shadowBias;\n  #endif\n  uniform sampler2D u_albedo_map;\n  #if _USEAOMAP_ON\n    uniform sampler2D u_ao_map;\n  #endif\n#if _USENORMALMAP_ON\n  uniform sampler2D u_normal_map;\n#endif\n#if _USEDETAILNORMALMAP_ON\n  uniform sampler2D u_detail_normal_map;\n#endif\n#if _USEMETALLICMAP_ON\n  uniform sampler2D u_metallic_map;\n#endif\n#if _USESSSMAP_ON\n  uniform sampler2D u_sss_map;\n#endif\n#if _USESPECULARMAP_ON\n  uniform sampler2D u_specular_map;\n#endif\n#if _USEDIFFUSERAMPMAP_ON\n  uniform sampler2D u_diffuseRamp_map;\n#endif\n#if _USEINDIRECTDIFFUSEMAP_ON\n  uniform sampler2D u_indirect_diffuse_map;\n#endif\n#if _USEINDIRECTSPECULARMAP_ON\n  uniform sampler2D u_indirect_specular_map;\n#endif\n#if _USEANISOTROPICMAP_ON\n  uniform sampler2D u_anisotropic_map;\n#endif\n#if _TOGGLEWAVE_ON\n  #if _USEWAVEMAP_ON\n    uniform sampler2D u_wave_map;\n  #endif\n#endif\n  float Remap(float inf, float minOld, float maxOld, float minNew, float maxNew)\n  {\n    return minNew + (inf - minOld) * (maxNew - minNew) / (maxOld - minOld);\n  }\n  vec2 CyLindricalUvMap(vec3 direction)\n  {\n    direction = normalize(direction);\n    float x = 0.75 - atan(direction.z, direction.x)/PI/2.0;\n    if(x>1.0)\n    {\n      x = x - 1.0;\n    }\n    return vec2(x, 1.0 - acos(direction.y)/PI);\n  }\n  vec3 Candy(vec3 normal, vec3 blinnPhongHalfVector,vec3 worldSpaceLightDir)\n  {\n    #if _USEANISOTROPICMAP_ON\n      return texture2D(u_anisotropic_map,vec2(Remap(dot(blinnPhongHalfVector,normal),-1.0,1.0,u_candyNv_range,1.0-u_candyNv_range), 1.0-Remap(dot(worldSpaceLightDir,normal),-1.0,1.0,u_candyNv_range,1.0-u_candyNv_range))).rgb * u_candy_intensity;\n    #else\n      return vec3(0.0);\n    #endif\n  }\n  vec3 Anisotropic(vec3 normal,vec3 blinnPhongHalfVector,vec3 worldSpaceLightDir,vec3 worldViewDir)\n  {\n    #if _ANISOTROPICOPTION_NONE\n      return vec3(0.0);\n    #endif\n    #if _ANISOTROPICOPTION_FROMNVSDK\n      #if _USEANISOTROPICMAP_ON\n        return texture2D(u_anisotropic_map, vec2(Remap(dot(blinnPhongHalfVector, normal), -1.0, 1.0, u_anisotropic_nvAmd, 1.0), 1.0 - Remap(dot(worldSpaceLightDir, normal), -1.0, 1.0, u_anisotropic_nvAmd, 1.0))).rgb;\n      #else\n        return vec3(0.0);\n      #endif\n    #endif\n    #if _ANISOTROPICOPTION_AMD\n      #if _USEANISOTROPICMAP_ON\n        return texture2D(u_anisotropic_map, vec2(Remap(dot(worldSpaceLightDir, v_Tangent.xyz), -1.0, 1.0, u_anisotropic_nvAmd, 1.0), 1.0 - Remap(dot(worldViewDir, v_Tangent.xyz), -1.0, 1.0, u_anisotropic_nvAmd, 1.0))).rgb;\n      #else\n        return vec3(0.0);\n      #endif\n    #endif\n    #if _ANISOTROPICOPTION_GMES1\n      return vec3(exp(-pow(dot( v_Tangent.xyz, blinnPhongHalfVector) * u_gmes_controlR / dot( normal, blinnPhongHalfVector), 2.0)));\n    #endif\n    #if _ANISOTROPICOPTION_RIM\n      return pow(1.0 - clamp(dot( normal, worldViewDir), 0.0, 0.999), u_rim_power) * u_rim_color.rgb;\n    #endif\n    return vec3(0.0);\n  }\n  float MipLevel(float roughness)\n  {\n    return (1.7 - roughness * 0.7) * roughness * 6.0;\n  }\n  vec3 FresnelLerp(vec3 specularColor, float grazingTerm, float nDotV)\n  {\n    return mix(specularColor, vec3(grazingTerm), pow( 1.0 - nDotV, 5.0));\n  }\n  vec3 FresnelTerm(vec3 specularColor, float cosA)\n  {\n    return (vec3(1.0) - specularColor) * pow(1.0 - cosA, 5.0) + specularColor;\n  }\n  float GGXTerm(float nDotH, float roughness)\n  {\n    float a2 = roughness * roughness;\n    float d = (nDotH * a2 - nDotH) * nDotH + 1.0;\n    return ((1.0/PI) * a2)/(d * d + pow(10.0, -7.0));\n  }\n  float SmithJoint(float nDotL,float nDotV,float roughness)\n  {\n    return 0.5/(((nDotL * (1.0 - roughness) + roughness) * nDotV) + (nDotL * (nDotV *(1.0 - roughness) + roughness)));\n  }\n  float DisneyDiffuse(float nDotV,float nDotL,float lDotH,float perceptualRoughness)\n  {\n    float fd90 = lDotH * lDotH * perceptualRoughness * 2.0 + 0.5;\n    return ((fd90 - 1.0) * pow(1.0 - nDotL, 5.0) + 1.0) * ((fd90 - 1.0) * pow(1.0 - nDotV, 5.0) + 1.0);\n  }\n  vec2 HalfLambertOffset(float uOffset, float vOffet,float halfLambert)\n  {\n    return vec2(clamp(uOffset+halfLambert, 0.0, 1.0), vOffet);\n  }\n  vec4 DiffuseRampToon(float halfLambert)\n  {\n    float rampHightChannel = 1.0;\n    #if _USEDIFFUSERAMPMAP_ON\n      vec2 uv_rampHightChannel = HalfLambertOffset(u_diffuseRampToon_u_high, u_diffuseRampToon_v, halfLambert);\n      uv_rampHightChannel = vec2(uv_rampHightChannel.x, uv_rampHightChannel.y);\n      rampHightChannel = texture2D(u_diffuseRamp_map, uv_rampHightChannel).r;\n    #endif\n    float rampMidChannel = 1.0;\n    #if _USEDIFFUSERAMPMAP_ON\n      vec2 uv_rampMidChannel = HalfLambertOffset(u_diffuseRampToon_u_mid, u_diffuseRampToon_v, halfLambert);\n      uv_rampMidChannel = vec2(uv_rampMidChannel.x, uv_rampMidChannel.y);\n      rampMidChannel = texture2D(u_diffuseRamp_map, uv_rampMidChannel).g;\n    #endif\n    float rampLowChannel = 1.0;\n    #if _USEDIFFUSERAMPMAP_ON\n      vec2 uv_rampLowChannel = HalfLambertOffset(u_diffuseRampToon_u_low, u_diffuseRampToon_v, halfLambert);\n      uv_rampLowChannel = vec2(uv_rampLowChannel.x, uv_rampLowChannel.y);\n      rampLowChannel = texture2D(u_diffuseRamp_map, uv_rampLowChannel).b;\n    #endif\n    float tintHighAlpha = u_tintcolor_high.a * rampHightChannel;\n    float tintMidAlpha = u_tintcolor_mid.a * rampMidChannel;\n    float tintLowAlpha = u_tintcolor_low.a * rampLowChannel;\n    vec3 rgb = mix(mix(mix(u_tintcolor_base.rgb, u_tintcolor_high.rgb, tintHighAlpha), u_tintcolor_mid.rgb, tintMidAlpha), u_tintcolor_low.rgb, tintLowAlpha);\n    return vec4(rgb.xyz, tintHighAlpha + tintMidAlpha + tintLowAlpha);\n  }\n  vec3 HSV2RGB_TB(vec3 c)\n  {\n      vec4 k = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n      return c.z * mix(k.xxx, clamp(abs(fract(c.xxx + k.xyz) * 6.0 - k.www) - k.xxx, 0.0, 1.0), c.y);\n  }\n  vec3 RGB2HSV_TB(vec3 c)\n  {\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    k = mix(vec4(c.bg, k.wz), vec4(c.gb, k.xy), step(c.b, c.g));\n    k = mix(vec4(k.xyw, c.r), vec4(c.r, k.yzx), step(k.x, c.r));\n    float d = k.x - min( k.w, k.y );\n    highp float e = 1.0e-10;\n    return vec3( abs(k.z + (k.w - k.y) / (6.0 * d + e)), d / (k.x + e), k.x);\n  }\n  vec3 HVSAO(vec3 c,float ao_s,float ao_r)\n  {\n      c = RGB2HSV_TB(c);\n    return HSV2RGB_TB(vec3(c.x, mix(clamp(c.y + ao_s, 0.0, 1.0), c.y, ao_r), c.z));\n  }\n  vec3 UnitySafeNormalize(vec3 inVec)\n  {\n      return inVec * inversesqrt(max(0.001, dot(inVec, inVec)));\n  }\n  vec3 MatCap(sampler2D inTex,vec3 inNormal)\n  {\n    vec2 matcap = (cc_matView * vec4(inNormal, 0.0)*0.45+0.5).xy;\n    return texture2D(inTex, vec2(matcap.x, 1.0 - matcap.y)).rgb;\n  }\n  vec2 UVTrans(vec2 uv,float mipLv)\n  {\n    mipLv = floor(mipLv);\n    float x_offset = 0.0;\n    float curSize_x = pow(2.0, 7.0 -mipLv);\n    for(float i = 0.0; i<10.0; ++i)\n    {\n      if(i>=mipLv)break;\n      x_offset = x_offset + pow(2.0, 7.0 - i);\n    }\n    return vec2((x_offset + uv.x * curSize_x)/256.0, uv.y * ((curSize_x/2.0)/64.0));\n  }\n  vec4 MipSample(sampler2D image, vec2 uv, float mipLv)\n  {\n    vec2 uv_floor = UVTrans(uv, floor(mipLv));\n    vec2 uv_ceil = UVTrans(uv, ceil(mipLv));\n    return mix(texture2D(image, vec2(uv_floor.x,1.0 - uv_floor.y)).rgba, texture2D(image, vec2(uv_ceil.x,1.0 - uv_ceil.y)).rgba, fract(mipLv));\n  }\n  vec3 UnpackScaleNormal(vec3 normalMapSample, float scale)\n  {\n    vec3 normalT;\n    normalT.x = 2.0 * normalMapSample.x - 1.0;\n    normalT.y = 1.0 - 2.0 * normalMapSample.y;\n    normalT.xy *= scale;\n    normalT.z = 2.0*normalMapSample.z - 1.0;\n    return normalT;\n  }\n  vec3 WorldNormalVector(vec3 packedNormal, vec3 unitNormal, vec3 tangent,vec3 binormal)\n  {\n    vec3 N = normalize(unitNormal);\n    vec3 T = normalize(tangent);\n    vec3 B = normalize(binormal);\n    mat3 TBN = mat3(T, B, N);\n    vec3 bumpedNormal = TBN*packedNormal;\n    return bumpedNormal;\n  }\n  vec3 NormalMapCombine(vec3 n1, vec3 n2)\n  {\n    #if _COMBINEOPTION_UNITYBLENDING\n      mat3 nBasis = mat3(\n        vec3(n1.z, n1.y, -n1.x),\n        vec3(n1.x, n1.z, -n1.y),\n        vec3(n1.x, n1.y,  n1.z));\n      vec3 r = normalize(n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);\n      return r;\n    #endif\n    return n1;\n  }\n  vec3 clampVec3(vec3 temp, float minV,float maxV)\n  {\n      float temp_x = clamp(temp.x,minV,maxV);\n      float temp_y = clamp(temp.y,minV,maxV);\n      float temp_z = clamp(temp.z,minV,maxV);\n      return vec3(temp_x,temp_y,temp_z);\n  }\n  vec4 clampVec4(vec4 temp, float minV,float maxV)\n  {\n      float temp_x = clamp(temp.x,minV,maxV);\n      float temp_y = clamp(temp.y,minV,maxV);\n      float temp_z = clamp(temp.z,minV,maxV);\n    float temp_w = clamp(temp.w,minV,maxV);\n      return vec4(temp_x,temp_y,temp_z,temp_w);\n  }\n  vec4 carLitFrag()\n  {\n    vec3 worldViewDir = UnitySafeNormalize(v_viewDir);\n    vec3 worldSpaceLightDir = UnitySafeNormalize(-cc_mainLitDir.xyz);\n    vec3 normal_final = vec3(0.0);\n    vec3 normal_map_rgb_base = vec3(0.5, 0.5, 1.0);\n    vec3 normal_map_rgb_detail = vec3(0.5, 0.5, 1.0);\n    float normal_b = 0.0;\n    #if _USENORMALMAP_ON\n      normal_map_rgb_base = texture2D(u_normal_map, v_Texcoord0).rgb;\n      normal_b = normal_map_rgb_base.b;\n      normal_map_rgb_base.b = 1.0;\n    #endif\n    normal_map_rgb_base = UnpackScaleNormal(normal_map_rgb_base, 1.0);\n    #if _USEDETAILNORMALMAP_ON\n      normal_map_rgb_detail = texture2D(u_detail_normal_map, v_Texcoord0*u_detail_normal_map_st.xy + u_detail_normal_map_st.zw).rgb;\n    #endif\n    normal_map_rgb_detail = UnpackScaleNormal(normal_map_rgb_detail, u_detail_normal_scale);\n    normal_final = NormalMapCombine(normal_map_rgb_base, normal_map_rgb_detail);\n    vec3 worldNormal = UnitySafeNormalize(WorldNormalVector(normal_final,v_Normal.xyz,v_Tangent.xyz,v_Binormal.xyz));\n    #if LINEAR_MODE\n      vec4 unity_color = vec4(0.04, 0.04, 0.04, 0.96);\n    #else\n      vec4 unity_color = vec4(0.22, 0.22, 0.22, 0.78);\n    #endif\n    float ao_r = 1.0;\n    #if _USEAOMAP_ON\n      ao_r = texture2D(u_ao_map, v_Texcoord0).r;\n    #endif\n    ao_r = mix(1.0, ao_r, u_ao_intense);\n    vec4 albedo_rgba = texture2D(u_albedo_map, v_Texcoord0);\n    vec3 albedo_rgb = RGB2HSV_TB(albedo_rgba.rgb);\n    albedo_rgb = HVSAO(HSV2RGB_TB(vec3(albedo_rgb.x, clamp(u_s_adjust + albedo_rgb.y, 0.0, 1.0), clamp(u_v_adjust + albedo_rgb.z, 0.0, 1.0))), u_ao_s_adjust, ao_r);\n    albedo_rgb = clampVec3(albedo_rgb,0.0,1.0);\n    vec4 specular_map_rgba = vec4(0.0, 0.0, 0.0, 1.0);\n    #if _USESPECULARMAP_ON\n      specular_map_rgba = texture2D(u_specular_map, v_Texcoord0);\n    #endif\n    vec3 metallic_rgb = vec3(0.5, 0.5, 0.5);\n    float metallic_a = 1.0;\n    #if _USEMETALLICMAP_ON\n      vec4 metallic_rgba = clampVec4(texture2D(u_metallic_map, v_Texcoord0).rgba,0.0,1.0);\n      metallic_rgb = metallic_rgba.rgb;\n      metallic_a = metallic_rgba.a;\n    #endif\n    float metallic = 0.0;\n    float gloss = 0.0;\n    float perceptualRoughness = 0.0;\n    float roughness = 0.0;\n    vec3 specularColor = vec3(0.0);\n    float oneMinusReflectivity = 0.0;\n    vec3 diffuseColor = vec3(0.0);\n    #if _TOOGLEPBRPIPELINE_METALLICSIMPLE\n      metallic = u_metallic;\n      gloss = u_glossness;\n      specularColor = mix(unity_color.xyz, albedo_rgb, metallic);\n      oneMinusReflectivity = unity_color.w * (1.0 - metallic);\n      diffuseColor = vec3(oneMinusReflectivity) * albedo_rgb;\n    #endif\n    #if _TOOGLEPBRPIPELINE_METALLICIMAGE\n      metallic = metallic_rgb.r;\n      gloss = metallic_rgb.g;\n      specularColor = mix(unity_color.xyz, albedo_rgb, metallic);\n      oneMinusReflectivity = unity_color.w * (1.0 - metallic);\n      diffuseColor = vec3(oneMinusReflectivity) * albedo_rgb;\n    #endif\n    #if _TOOGLEPBRPIPELINE_SPECULARSIMPLE\n      metallic = 0.0;\n      gloss = u_glossness;\n      specularColor = u_specular_color.rgb;\n      oneMinusReflectivity = 1.0 - max(max(specularColor.x, specularColor.y), specularColor.z);\n      diffuseColor = (vec3(1.0, 1.0, 1.0) - specularColor) * albedo_rgb;\n    #endif\n    #if _TOOGLEPBRPIPELINE_SPECULARIMAGE\n      metallic = 0.0;\n      gloss = specular_map_rgba.a;\n      specularColor = specular_map_rgba.xyz;\n      oneMinusReflectivity = 1.0 - max(max(specularColor.x, specularColor.y), specularColor.z);\n      diffuseColor = (vec3(1.0, 1.0, 1.0) - specularColor) * albedo_rgb;\n    #endif\n    perceptualRoughness = 1.0 - gloss;\n    roughness = max(perceptualRoughness * perceptualRoughness, 0.002);\n    vec3 blinnPhongHalfVector = normalize(worldViewDir + worldSpaceLightDir);\n    float nDotL = clamp(dot(worldNormal, worldSpaceLightDir), 0.0, 1.0);\n    float lDotH = clamp(dot(worldSpaceLightDir, blinnPhongHalfVector), 0.0, 1.0);\n    float nDotV = abs(dot(worldNormal, worldViewDir));\n    vec3 attenColor = vec3(0.7, 0.69,0.67);\n    float halfLambert =  dot(worldNormal, worldSpaceLightDir) *0.5 + 0.5;\n    vec3 bloodColor =vec3(0.0);\n    #if _TOGGLEDIFFUSERAMP_NONE\n      bloodColor = vec3(nDotL);\n    #endif\n    #if _USESSSMAP_ON\n      bloodColor = texture2D(u_sss_map, vec2(halfLambert, 1.0 - u_bloodValue)).rgb;\n    #endif\n    #if _TOGGLEDIFFUSERAMP_DIFFUSERAMP\n      bloodColor = DiffuseRampToon(halfLambert).xyz;\n    #endif\n    vec3 indirectDiffuse =vec3(0.0);\n    #if _USEINDIRECTDIFFUSEMAP_ON\n      indirectDiffuse = MatCap(u_indirect_diffuse_map, worldNormal) * ao_r;\n    #endif\n    float specular_temp1 = 0.0;\n    if(specularColor != vec3(0.0, 0.0,0.0))\n    {\n      specular_temp1 = 1.0;\n    }\n    #if LINEAR_MODE\n      float surfaceReduction = 1.0 / (roughness * roughness + 1.0);\n    #else\n      float surfaceReduction = 1.0 - roughness * perceptualRoughness * 0.28;\n    #endif\n    vec3 direction = reflect(-worldViewDir,worldNormal);\n    direction = vec3(-direction.x,direction.y,direction.z);\n    direction = normalize(direction);\n    vec2 indirect_specular_uv = CyLindricalUvMap(direction);\n    vec3 indirect_specular_rgb = vec3(0.5);\n    indirect_specular_uv = vec2(indirect_specular_uv.x, indirect_specular_uv.y);\n    #if _USEINDIRECTSPECULARMAP_ON\n      indirect_specular_rgb = MipSample(u_indirect_specular_map, indirect_specular_uv, MipLevel(perceptualRoughness) + u_miplv_offset).rgb;\n    #endif\n    indirect_specular_rgb = indirect_specular_rgb * u_m_factor;\n    vec3 indirectSpecular = FresnelLerp(specularColor, clamp(gloss + (1.0 - oneMinusReflectivity), 0.0, 1.0), nDotV) * surfaceReduction * indirect_specular_rgb;\n    vec3 specular = max(sqrt(max(SmithJoint(nDotL, nDotV, roughness) * GGXTerm(clamp(dot(worldNormal, blinnPhongHalfVector), 0.0, 1.0), roughness) * PI, 0.0001)) * nDotL, 0.0) * specular_temp1 * FresnelTerm(specularColor, lDotH) * attenColor + indirectSpecular;\n    vec3 anisotropicRGB = Anisotropic(worldNormal, blinnPhongHalfVector, worldSpaceLightDir, worldViewDir) * metallic_rgb.b;\n    vec3 wave = vec3(0.0);\n    #if _TOGGLEWAVE_ON\n      #if _USEWAVEMAP_ON\n        vec2 wave_temp1 = v_Texcoord0 * u_wave_map_st.xy + u_wave_map_st.zw;\n        float wave_time = u_Time/10.0;\n        wave_temp1 = wave_temp1 + vec2(wave_time*u_waveSpeedX , wave_time*u_waveSpeedY);\n        wave = texture2D(u_wave_map, wave_temp1).rgb * normal_b * u_waveAlpha;\n      #endif\n    #endif\n    vec3 flicker = vec3(0.0);\n    #if _TOGGLEFLICKER_ON\n      flicker = u_flicker_color.xyz *  metallic_rgb.b * abs(cos(u_Time * u_flickerSpeed * 4.0 + 3.0));\n    #endif\n    vec3 tempFinalCol = (indirectDiffuse + bloodColor * DisneyDiffuse(nDotV, nDotL, lDotH, perceptualRoughness) * attenColor) * diffuseColor + specular + anisotropicRGB +  wave + flicker;\n    #if _TOOGLECANDY_ON\n      tempFinalCol = mix(tempFinalCol, tempFinalCol * Candy(worldNormal, blinnPhongHalfVector, worldSpaceLightDir), metallic_rgb.b);\n    #endif\n    vec4 finalCol = vec4(0.0);\n      finalCol.rgb = tempFinalCol;\n    #if _ALPHA_ALBEDO\n        finalCol.a = albedo_rgba.a;\n    #else\n      finalCol.a = 1.0;\n    #endif\n    return finalCol;\n  }\n  vec4 frag ()\n  {\n    vec4 outCol= carLitFrag();\n    if(outCol.a < u_clip_threshold){ discard;}\n    #if _CLIP_COLOR\n        if ( outCol.a < 1.01 ) discard;\n    #endif\n    return outCol;\n  }\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_diffuseMap","defines":[]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":164,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":136}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"COLOR","type":"boolean"},{"name":"ENABLEVERTEXCOLOR","type":"boolean"},{"name":"SAMPLE_FROM_RT","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"_USEAOMAP_ON","type":"boolean"},{"name":"_USENORMALMAP_ON","type":"boolean"},{"name":"_USEDETAILNORMALMAP_ON","type":"boolean"},{"name":"_USEMETALLICMAP_ON","type":"boolean"},{"name":"_USESSSMAP_ON","type":"boolean"},{"name":"_USESPECULARMAP_ON","type":"boolean"},{"name":"_USEDIFFUSERAMPMAP_ON","type":"boolean"},{"name":"_USEINDIRECTDIFFUSEMAP_ON","type":"boolean"},{"name":"_USEINDIRECTSPECULARMAP_ON","type":"boolean"},{"name":"_USEANISOTROPICMAP_ON","type":"boolean"},{"name":"_TOGGLEWAVE_ON","type":"boolean"},{"name":"_USEWAVEMAP_ON","type":"boolean"},{"name":"_ANISOTROPICOPTION_NONE","type":"boolean"},{"name":"_ANISOTROPICOPTION_FROMNVSDK","type":"boolean"},{"name":"_ANISOTROPICOPTION_AMD","type":"boolean"},{"name":"_ANISOTROPICOPTION_GMES1","type":"boolean"},{"name":"_ANISOTROPICOPTION_RIM","type":"boolean"},{"name":"_COMBINEOPTION_UNITYBLENDING","type":"boolean"},{"name":"LINEAR_MODE","type":"boolean"},{"name":"_TOOGLEPBRPIPELINE_METALLICSIMPLE","type":"boolean"},{"name":"_TOOGLEPBRPIPELINE_METALLICIMAGE","type":"boolean"},{"name":"_TOOGLEPBRPIPELINE_SPECULARSIMPLE","type":"boolean"},{"name":"_TOOGLEPBRPIPELINE_SPECULARIMAGE","type":"boolean"},{"name":"_TOGGLEDIFFUSERAMP_NONE","type":"boolean"},{"name":"_TOGGLEDIFFUSERAMP_DIFFUSERAMP","type":"boolean"},{"name":"_TOGGLEFLICKER_ON","type":"boolean"},{"name":"_TOOGLECANDY_ON","type":"boolean"},{"name":"_ALPHA_ALBEDO","type":"boolean"},{"name":"_CLIP_COLOR","type":"boolean"}]},{"hash":1137604673,"name":"../sdk/res/mat/car|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"u_detail_normal_map_st","type":16,"count":1},{"name":"u_specular_color","type":16,"count":1},{"name":"u_tintcolor_base","type":16,"count":1},{"name":"u_tintcolor_high","type":16,"count":1},{"name":"u_tintcolor_mid","type":16,"count":1},{"name":"u_tintcolor_low","type":16,"count":1},{"name":"u_rim_color","type":16,"count":1},{"name":"u_wave_map_st","type":16,"count":1},{"name":"u_flicker_color","type":16,"count":1},{"name":"u_TilingOffset","type":16,"count":1},{"name":"u_s_adjust","type":13,"count":1},{"name":"u_v_adjust","type":13,"count":1},{"name":"u_ao_intense","type":13,"count":1},{"name":"u_ao_s_adjust","type":13,"count":1},{"name":"u_detail_normal_scale","type":13,"count":1},{"name":"u_metallic","type":13,"count":1},{"name":"u_glossness","type":13,"count":1},{"name":"u_bloodValue","type":13,"count":1},{"name":"u_diffuseRampToon_v","type":13,"count":1},{"name":"u_diffuseRampToon_u_high","type":13,"count":1},{"name":"u_diffuseRampToon_u_mid","type":13,"count":1},{"name":"u_diffuseRampToon_u_low","type":13,"count":1},{"name":"u_anisotropic_nvAmd","type":13,"count":1},{"name":"u_gmes_controlR","type":13,"count":1},{"name":"u_rim_power","type":13,"count":1},{"name":"u_candyNv_range","type":13,"count":1},{"name":"u_candy_intensity","type":13,"count":1},{"name":"u_Time","type":13,"count":1},{"name":"u_waveAlpha","type":13,"count":1},{"name":"u_waveSpeedX","type":13,"count":1},{"name":"u_waveSpeedY","type":13,"count":1},{"name":"u_flickerSpeed","type":13,"count":1},{"name":"u_miplv_offset","type":13,"count":1},{"name":"u_m_factor","type":13,"count":1},{"name":"u_clip_threshold","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"u_albedo_map","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":15,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"u_detail_normal_map_st","type":16,"count":1},{"name":"u_specular_color","type":16,"count":1},{"name":"u_tintcolor_base","type":16,"count":1},{"name":"u_tintcolor_high","type":16,"count":1},{"name":"u_tintcolor_mid","type":16,"count":1},{"name":"u_tintcolor_low","type":16,"count":1},{"name":"u_rim_color","type":16,"count":1},{"name":"u_wave_map_st","type":16,"count":1},{"name":"u_flicker_color","type":16,"count":1},{"name":"u_TilingOffset","type":16,"count":1},{"name":"u_s_adjust","type":13,"count":1},{"name":"u_v_adjust","type":13,"count":1},{"name":"u_ao_intense","type":13,"count":1},{"name":"u_ao_s_adjust","type":13,"count":1},{"name":"u_detail_normal_scale","type":13,"count":1},{"name":"u_metallic","type":13,"count":1},{"name":"u_glossness","type":13,"count":1},{"name":"u_bloodValue","type":13,"count":1},{"name":"u_diffuseRampToon_v","type":13,"count":1},{"name":"u_diffuseRampToon_u_high","type":13,"count":1},{"name":"u_diffuseRampToon_u_mid","type":13,"count":1},{"name":"u_diffuseRampToon_u_low","type":13,"count":1},{"name":"u_anisotropic_nvAmd","type":13,"count":1},{"name":"u_gmes_controlR","type":13,"count":1},{"name":"u_rim_power","type":13,"count":1},{"name":"u_candyNv_range","type":13,"count":1},{"name":"u_candy_intensity","type":13,"count":1},{"name":"u_Time","type":13,"count":1},{"name":"u_waveAlpha","type":13,"count":1},{"name":"u_waveSpeedX","type":13,"count":1},{"name":"u_waveSpeedY","type":13,"count":1},{"name":"u_flickerSpeed","type":13,"count":1},{"name":"u_miplv_offset","type":13,"count":1},{"name":"u_m_factor","type":13,"count":1},{"name":"u_clip_threshold","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"u_albedo_map","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_1","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_2","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_3","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 u_detail_normal_map_st;\n  vec4 u_specular_color;\n   vec4 u_tintcolor_base;\n   vec4 u_tintcolor_high;\n   vec4 u_tintcolor_mid;\n   vec4 u_tintcolor_low;\n   vec4 u_rim_color;\n   vec4 u_wave_map_st;\n    vec4 u_flicker_color;\n    vec4 u_TilingOffset;\n   float u_s_adjust;\n   float u_v_adjust;\n   float u_ao_intense;\n   float u_ao_s_adjust;\n  float u_detail_normal_scale;\n   float u_metallic;\n   float u_glossness;\n   float u_bloodValue;\n   float u_diffuseRampToon_v;\n   float u_diffuseRampToon_u_high;\n   float u_diffuseRampToon_u_mid;\n   float u_diffuseRampToon_u_low;\n   float u_anisotropic_nvAmd;\n   float u_gmes_controlR;\n   float u_rim_power;\n   float u_candyNv_range;\n   float u_candy_intensity;\n   float u_Time;\n   float u_waveAlpha;\n   float u_waveSpeedX;\n   float u_waveSpeedY;\n   float u_flickerSpeed;\n   float u_miplv_offset;\n   float u_m_factor;\n   float u_clip_threshold;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nout vec2 v_Texcoord0;\nout vec4 v_worldPos;\nout highp vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_Texcoord0 = a_texCoord * u_TilingOffset.xy + u_TilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 u_detail_normal_map_st;\n  vec4 u_specular_color;\n   vec4 u_tintcolor_base;\n   vec4 u_tintcolor_high;\n   vec4 u_tintcolor_mid;\n   vec4 u_tintcolor_low;\n   vec4 u_rim_color;\n   vec4 u_wave_map_st;\n    vec4 u_flicker_color;\n    vec4 u_TilingOffset;\n   float u_s_adjust;\n   float u_v_adjust;\n   float u_ao_intense;\n   float u_ao_s_adjust;\n  float u_detail_normal_scale;\n   float u_metallic;\n   float u_glossness;\n   float u_bloodValue;\n   float u_diffuseRampToon_v;\n   float u_diffuseRampToon_u_high;\n   float u_diffuseRampToon_u_mid;\n   float u_diffuseRampToon_u_low;\n   float u_anisotropic_nvAmd;\n   float u_gmes_controlR;\n   float u_rim_power;\n   float u_candyNv_range;\n   float u_candy_intensity;\n   float u_Time;\n   float u_waveAlpha;\n   float u_waveSpeedX;\n   float u_waveSpeedY;\n   float u_flickerSpeed;\n   float u_miplv_offset;\n   float u_m_factor;\n   float u_clip_threshold;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n    mediump vec4 cc_debug_view_mode;\n    mediump vec4 cc_debug_view_composite_pack_1;\n    mediump vec4 cc_debug_view_composite_pack_2;\n    mediump vec4 cc_debug_view_composite_pack_3;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_surfaceTransform;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nin vec2 v_Texcoord0;\nin vec4 v_worldPos;\nin highp vec2 v_clip_depth;\nuniform sampler2D u_albedo_map;\nvec4 frag ()\n{\n  #if _ALPHA_ALBEDO\n    vec4 baseColor = texture(u_albedo_map, v_Texcoord0);\n    if (baseColor.a < 0.5) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999)\n  {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 u_TilingOffset;\nuniform highp mat4 cc_matLightViewProj;\nvarying vec2 v_Texcoord0;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_Texcoord0 = a_texCoord * u_TilingOffset.xy + u_TilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nvarying vec2 v_Texcoord0;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\nuniform sampler2D u_albedo_map;\nvec4 frag ()\n{\n  #if _ALPHA_ALBEDO\n    vec4 baseColor = texture2D(u_albedo_map, v_Texcoord0);\n    if (baseColor.a < 0.5) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999)\n  {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":79,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":136}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"_ALPHA_ALBEDO","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"../sdk/res/mat/car|car-vs:vert|car-fs:frag","rasterizerState":{"cullMode":2},"blendState":{"targets":[{"blend":false,"blendSrc":0,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":3,"depthTest":true,"depthWrite":true},"properties":{"u_albedo_map":{"value":"grey","type":28},"u_TilingOffset":{"type":16,"value":[1,1,0,0]},"u_s_adjust":{"type":13,"value":[0]},"u_v_adjust":{"type":13,"value":[0]},"u_ao_map":{"value":"white","type":28},"u_ao_intense":{"type":13,"value":[0]},"u_ao_s_adjust":{"type":13,"value":[0]},"u_normal_map":{"value":"normal","type":28},"u_detail_normal_scale":{"type":13,"value":[1]},"u_detail_normal_map":{"value":"normal","type":28},"u_detail_normal_map_st":{"type":16,"value":[1,1,0,0]},"u_metallic":{"type":13,"value":[0]},"u_metallic_map":{"value":"white","type":28},"u_glossness":{"type":13,"value":[0]},"u_bloodValue":{"type":13,"value":[1]},"u_sss_map":{"value":"white","type":28},"u_specular_map":{"value":"white","type":28},"u_specular_color":{"linear":true,"type":16,"value":[1,1,1,1]},"u_diffuseRampToon_v":{"type":13,"value":[1]},"u_diffuseRampToon_u_high":{"type":13,"value":[1]},"u_diffuseRampToon_u_mid":{"type":13,"value":[1]},"u_diffuseRampToon_u_low":{"type":13,"value":[1]},"u_tintcolor_base":{"linear":true,"type":16,"value":[1,1,1,1]},"u_tintcolor_high":{"linear":true,"type":16,"value":[1,1,1,1]},"u_tintcolor_mid":{"linear":true,"type":16,"value":[1,1,1,1]},"u_tintcolor_low":{"linear":true,"type":16,"value":[1,1,1,1]},"u_diffuseRamp_map":{"value":"white","type":28},"u_indirect_diffuse_map":{"value":"white","type":28},"u_indirect_specular_map":{"value":"white","type":28},"u_anisotropic_map":{"value":"white","type":28},"u_anisotropic_nvAmd":{"type":13,"value":[-1]},"u_gmes_controlR":{"type":13,"value":[8]},"u_rim_power":{"type":13,"value":[1]},"u_rim_color":{"linear":true,"type":16,"value":[1,1,1,1]},"u_candyNv_range":{"type":13,"value":[0]},"u_candy_intensity":{"type":13,"value":[1]},"u_Time":{"type":13,"value":[0]},"u_wave_map":{"value":"white","type":28},"u_wave_map_st":{"type":16,"value":[1,1,0,0]},"u_waveAlpha":{"type":13,"value":[0]},"u_waveSpeedX":{"type":13,"value":[0]},"u_waveSpeedY":{"type":13,"value":[0]},"u_flickerSpeed":{"type":13,"value":[0]},"u_flicker_color":{"type":16,"value":[1,1,1,1]},"u_miplv_offset":{"type":13,"value":[0]},"u_m_factor":{"type":13,"value":[0]},"u_clip_threshold":{"type":13,"value":[0]}}},{"phase":"forward-add","propertyIndex":0,"program":"../sdk/res/mat/car|car-vs:vert|car-fs:frag","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"../sdk/res/mat/car|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":2},"properties":{"u_TilingOffset":{"type":16,"value":[1,1,0,0]},"u_albedo_map":{"value":"grey","type":28}}}]}]]],0,0,[],[],[]]]]
