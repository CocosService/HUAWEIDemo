[1,["aefxIwA/xDp5MMaNpWVa9l"],["_effectAsset"],[["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Material",["_name","_props","_states","_defines"],-1]],[[0,0,1,2,4],[1,0,1,2,3,5]],[[[[0,"../sdk/res/mat/hair",[{"hash":2623328208,"name":"../sdk/res/mat/hair|hair-vs:vert|hair-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"u_bottom_dye_color","type":16,"count":1},{"name":"u_top_dye_color","type":16,"count":1},{"name":"u_middle_dye_color","type":16,"count":1},{"name":"u_primary_color","type":16,"count":1},{"name":"u_secondary_color","type":16,"count":1},{"name":"u_detail_normal_map_st","type":16,"count":1},{"name":"u_specular_color","type":16,"count":1},{"name":"u_tintcolor_base","type":16,"count":1},{"name":"u_tintcolor_high","type":16,"count":1},{"name":"u_tintcolor_mid","type":16,"count":1},{"name":"u_tintcolor_low","type":16,"count":1},{"name":"u_TilingOffset","type":16,"count":1},{"name":"u_primary_shift","type":13,"count":1},{"name":"u_primary_exponent","type":13,"count":1},{"name":"u_secondary_shift","type":13,"count":1},{"name":"u_secondary_exponent","type":13,"count":1},{"name":"u_ao_intense","type":13,"count":1},{"name":"u_normal_scale","type":13,"count":1},{"name":"u_detail_normal_scale","type":13,"count":1},{"name":"u_metallic","type":13,"count":1},{"name":"u_glossness","type":13,"count":1},{"name":"u_bloodValue","type":13,"count":1},{"name":"u_diffuseRampToon_v","type":13,"count":1},{"name":"u_diffuseRampToon_u_high","type":13,"count":1},{"name":"u_diffuseRampToon_u_mid","type":13,"count":1},{"name":"u_diffuseRampToon_u_low","type":13,"count":1},{"name":"u_miplv_offset","type":13,"count":1},{"name":"u_m_factor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"u_albedo_map","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]},{"name":"u_dye_map","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["_USEDYEMAP_ON"]},{"name":"u_hair_shift_map","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["_USEHAIRSHIFTMAP_ON"]},{"name":"u_ao_map","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["_USEAOMAP_ON"]},{"name":"u_normal_map","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["_USENORMALMAP_ON"]},{"name":"u_detail_normal_map","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["_USEDETAILNORMALMAP_ON"]},{"name":"u_metallic_map","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["_USEMETALLICMAP_ON"]},{"name":"u_sss_map","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["_USESSSMAP_ON"]},{"name":"u_specular_map","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["_USESPECULARMAP_ON"]},{"name":"u_diffuseRamp_map","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["_USEDIFFUSERAMPMAP_ON"]},{"name":"u_indirect_diffuse_map","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["_USEINDIRECTDIFFUSEMAP_ON"]},{"name":"u_indirect_specular_map","type":28,"count":1,"stageFlags":16,"binding":12,"defines":["_USEINDIRECTSPECULARMAP_ON"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":15,"defines":["CC_USE_MORPH"]},{"name":"a_Color","format":44,"location":16,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"u_bottom_dye_color","type":16,"count":1},{"name":"u_top_dye_color","type":16,"count":1},{"name":"u_middle_dye_color","type":16,"count":1},{"name":"u_primary_color","type":16,"count":1},{"name":"u_secondary_color","type":16,"count":1},{"name":"u_detail_normal_map_st","type":16,"count":1},{"name":"u_specular_color","type":16,"count":1},{"name":"u_tintcolor_base","type":16,"count":1},{"name":"u_tintcolor_high","type":16,"count":1},{"name":"u_tintcolor_mid","type":16,"count":1},{"name":"u_tintcolor_low","type":16,"count":1},{"name":"u_TilingOffset","type":16,"count":1},{"name":"u_primary_shift","type":13,"count":1},{"name":"u_primary_exponent","type":13,"count":1},{"name":"u_secondary_shift","type":13,"count":1},{"name":"u_secondary_exponent","type":13,"count":1},{"name":"u_ao_intense","type":13,"count":1},{"name":"u_normal_scale","type":13,"count":1},{"name":"u_detail_normal_scale","type":13,"count":1},{"name":"u_metallic","type":13,"count":1},{"name":"u_glossness","type":13,"count":1},{"name":"u_bloodValue","type":13,"count":1},{"name":"u_diffuseRampToon_v","type":13,"count":1},{"name":"u_diffuseRampToon_u_high","type":13,"count":1},{"name":"u_diffuseRampToon_u_mid","type":13,"count":1},{"name":"u_diffuseRampToon_u_low","type":13,"count":1},{"name":"u_miplv_offset","type":13,"count":1},{"name":"u_m_factor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"u_albedo_map","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]},{"name":"u_dye_map","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["_USEDYEMAP_ON"]},{"name":"u_hair_shift_map","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["_USEHAIRSHIFTMAP_ON"]},{"name":"u_ao_map","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["_USEAOMAP_ON"]},{"name":"u_normal_map","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["_USENORMALMAP_ON"]},{"name":"u_detail_normal_map","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["_USEDETAILNORMALMAP_ON"]},{"name":"u_metallic_map","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["_USEMETALLICMAP_ON"]},{"name":"u_sss_map","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["_USESSSMAP_ON"]},{"name":"u_specular_map","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["_USESPECULARMAP_ON"]},{"name":"u_diffuseRamp_map","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["_USEDIFFUSERAMPMAP_ON"]},{"name":"u_indirect_diffuse_map","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["_USEINDIRECTDIFFUSEMAP_ON"]},{"name":"u_indirect_specular_map","type":28,"count":1,"stageFlags":16,"binding":12,"defines":["_USEINDIRECTSPECULARMAP_ON"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_1","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_2","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_3","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 u_bottom_dye_color;\n  vec4 u_top_dye_color;\n  vec4 u_middle_dye_color;\n  vec4 u_primary_color;\n  vec4 u_secondary_color;\n  vec4 u_detail_normal_map_st;\n  vec4 u_specular_color;\n  vec4 u_tintcolor_base;\n  vec4 u_tintcolor_high;\n  vec4 u_tintcolor_mid;\n  vec4 u_tintcolor_low;\n  vec4 u_TilingOffset;\n  float u_primary_shift;\n  float u_primary_exponent;\n  float u_secondary_shift;\n  float u_secondary_exponent;\n  float u_ao_intense;\n  float u_normal_scale;\n  float u_detail_normal_scale;\n  float u_metallic;\n  float u_glossness;\n  float u_bloodValue;\n  float u_diffuseRampToon_v;\n  float u_diffuseRampToon_u_high;\n  float u_diffuseRampToon_u_mid;\n  float u_diffuseRampToon_u_low;\n  float u_miplv_offset;\n  float u_m_factor;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nmat4 matWorld;\nmat4 matWorldIT;\nvec4 TransformObjectToWorld(vec4 localPos)\n{\n    vec4 wsPos = matWorld * localPos;\n    return wsPos;\n}\nvec4 TransformWorldToHClip(vec4 wsPos)\n{\n    return cc_matViewProj* wsPos;\n}\nvec3 TransformObjectToWorldDir(vec3 localDir)\n{\n    vec3 wsDir = normalize((matWorld * vec4(localDir, 0.0)).xyz);\n    return wsDir;\n}\nvec3 TransformObjectToWorldNormal(vec3 localNormal)\n{\n    vec3 wsNormal = normalize((matWorldIT * vec4(localNormal, 0.0)).xyz);\n    return wsNormal;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    out vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n      v_luv.z = cc_lightingMapUVParam.w;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n      v_luv.z = a_lightingMapUVParam.w;\n    #endif\n    }\n#endif\nin vec4 a_Color;\nout lowp vec4 v_Color;\nout vec2 v_Texcoord0;\nout mediump vec3 v_worldPos;\nout mediump vec3 v_viewDir;\nout mediump vec4 v_Tangent;\nout mediump vec4 v_Normal;\nout mediump vec4 v_Binormal;\n#if CC_RECEIVE_SHADOW\n    out mediump vec2 v_shadowBias;\n#endif\nvec4 hairLitVert()\n{\n    StandardVertInput In; CCVertInput(In); CCGetWorldMatrixFull(matWorld, matWorldIT);\n    vec4 wsPos=TransformObjectToWorld(In.position);\n    v_worldPos = wsPos.xyz;\n    v_Normal.xyz=TransformObjectToWorldNormal(In.normal);\n    v_Tangent.xyz=TransformObjectToWorldDir(In.tangent.xyz);\n    v_Binormal.xyz=cross(v_Normal.xyz,v_Tangent.xyz)*In.tangent.w;\n    v_Texcoord0 = a_texCoord * u_TilingOffset.xy + u_TilingOffset.zw;\n    v_viewDir = cc_cameraPos.xyz - v_worldPos;\n    #if COLOR && ENABLEVERTEXCOLOR\n        v_Color = a_Color;\n    #endif\n    #if CC_RECEIVE_SHADOW\n      v_shadowBias = CCGetShadowBias();\n    #endif\n    #if SAMPLE_FROM_RT\n      v_Texcoord0 = cc_cameraPos.w > 1.0 ? vec2(v_Texcoord0.x, 1.0 - v_Texcoord0.y) : v_Texcoord0;\n    #endif\n    CC_TRANSFER_FOG(wsPos);\n    v_shadowPos = cc_matLightViewProj * wsPos;\n    #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n      CCLightingMapCaclUV();\n    #endif\n    return TransformWorldToHClip(wsPos);\n}\nvec4 vert ()\n{\n  return hairLitVert();\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 u_bottom_dye_color;\n  vec4 u_top_dye_color;\n  vec4 u_middle_dye_color;\n  vec4 u_primary_color;\n  vec4 u_secondary_color;\n  vec4 u_detail_normal_map_st;\n  vec4 u_specular_color;\n  vec4 u_tintcolor_base;\n  vec4 u_tintcolor_high;\n  vec4 u_tintcolor_mid;\n  vec4 u_tintcolor_low;\n  vec4 u_TilingOffset;\n  float u_primary_shift;\n  float u_primary_exponent;\n  float u_secondary_shift;\n  float u_secondary_exponent;\n  float u_ao_intense;\n  float u_normal_scale;\n  float u_detail_normal_scale;\n  float u_metallic;\n  float u_glossness;\n  float u_bloodValue;\n  float u_diffuseRampToon_v;\n  float u_diffuseRampToon_u_high;\n  float u_diffuseRampToon_u_mid;\n  float u_diffuseRampToon_u_low;\n  float u_miplv_offset;\n  float u_m_factor;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if !CC_USE_ACCURATE_FOG\nin mediump float v_fog_factor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    in vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n#endif\nin lowp vec4 v_Color;\nin vec2 v_Texcoord0;\nin vec3 v_worldPos;\nin mediump vec3 v_viewDir;\nin mediump vec4 v_Normal;\nin mediump vec4 v_Tangent;\nin mediump vec4 v_Binormal;\nuniform sampler2D u_albedo_map;\n#if _USEDYEMAP_ON\n  uniform sampler2D u_dye_map;\n#endif\n#if _USEHAIRSHIFTMAP_ON\n  uniform sampler2D u_hair_shift_map;\n#endif\n#if _USEAOMAP_ON\n  uniform sampler2D u_ao_map;\n#endif\n#if _USENORMALMAP_ON\n  uniform sampler2D u_normal_map;\n#endif\n#if _USEDETAILNORMALMAP_ON\n  uniform sampler2D u_detail_normal_map;\n#endif\n#if _USEMETALLICMAP_ON\n  uniform sampler2D u_metallic_map;\n#endif\n#if _USESSSMAP_ON\n  uniform sampler2D u_sss_map;\n#endif\n#if _USESPECULARMAP_ON\n  uniform sampler2D u_specular_map;\n#endif\n#if _USEDIFFUSERAMPMAP_ON\n  uniform sampler2D u_diffuseRamp_map;\n#endif\n#if _USEINDIRECTDIFFUSEMAP_ON\n  uniform sampler2D u_indirect_diffuse_map;\n#endif\n#if _USEINDIRECTSPECULARMAP_ON\n  uniform sampler2D u_indirect_specular_map;\n#endif\nvec2 CyLindricalUvMap(vec3 direction)\n{\n  direction = normalize(direction);\n  float x = 0.75 - atan(direction.z, direction.x)/PI/2.0;\n  if(x>1.0)\n  {\n    x = x - 1.0;\n  }\n  return vec2(x, 1.0 - acos(direction.y)/PI);\n}\nfloat MipLevel(float roughness)\n{\n  return (1.7 - roughness * 0.7) * roughness * 6.0;\n}\nvec3 FresnelLerp(vec3 specularColor, float grazingTerm, float nDotV)\n{\n  return mix(specularColor, vec3(grazingTerm), pow( 1.0 - nDotV, 5.0));\n}\nfloat DisneyDiffuse(float nDotV,float nDotL,float lDotH,float perceptualRoughness)\n{\n  float fd90 = lDotH * lDotH * perceptualRoughness * 2.0 + 0.5;\n  return ((fd90 - 1.0) * pow(1.0 - nDotL, 5.0) + 1.0) * ((fd90 - 1.0) * pow(1.0 - nDotV, 5.0) + 1.0);\n}\nvec2 HalfLambertOffset(float uOffset, float vOffet,float halfLambert)\n{\n  return vec2(clamp(uOffset+halfLambert, 0.0, 1.0), vOffet);\n}\nvec4 DiffuseRampToon(float halfLambert)\n{\n  float rampHightChannel = 1.0;\n  #if _USEDIFFUSERAMPMAP_ON\n    vec2 uv_rampHightChannel = HalfLambertOffset(u_diffuseRampToon_u_high, u_diffuseRampToon_v, halfLambert);\n    uv_rampHightChannel = vec2(uv_rampHightChannel.x, uv_rampHightChannel.y);\n    rampHightChannel = texture(u_diffuseRamp_map, uv_rampHightChannel).r;\n  #endif\n  float rampMidChannel = 1.0;\n  #if _USEDIFFUSERAMPMAP_ON\n    vec2 uv_rampMidChannel = HalfLambertOffset(u_diffuseRampToon_u_mid, u_diffuseRampToon_v, halfLambert);\n    uv_rampMidChannel = vec2(uv_rampMidChannel.x, uv_rampMidChannel.y);\n    rampMidChannel = texture(u_diffuseRamp_map, uv_rampMidChannel).g;\n  #endif\n  float rampLowChannel = 1.0;\n  #if _USEDIFFUSERAMPMAP_ON\n    vec2 uv_rampLowChannel = HalfLambertOffset(u_diffuseRampToon_u_low, u_diffuseRampToon_v, halfLambert);\n    uv_rampLowChannel = vec2(uv_rampLowChannel.x, uv_rampLowChannel.y);\n    rampLowChannel = texture(u_diffuseRamp_map, uv_rampLowChannel).b;\n  #endif\n  float tintHighAlpha = u_tintcolor_high.a * rampHightChannel;\n  float tintMidAlpha = u_tintcolor_mid.a * rampMidChannel;\n  float tintLowAlpha = u_tintcolor_low.a * rampLowChannel;\n  vec3 rgb = mix(mix(mix(u_tintcolor_base.rgb, u_tintcolor_high.rgb, tintHighAlpha), u_tintcolor_mid.rgb, tintMidAlpha), u_tintcolor_low.rgb, tintLowAlpha);\n  return vec4(rgb.xyz, tintHighAlpha + tintMidAlpha + tintLowAlpha);\n}\nvec3 UnitySafeNormalize(vec3 inVec)\n{\n    return inVec * inversesqrt(max(0.001, dot(inVec, inVec)));\n}\nvec3 MatCap(sampler2D inTex,vec3 inNormal)\n{\n  vec2 matcap = (cc_matView * vec4(inNormal, 0.0)*0.45+0.5).xy;\n  return texture(inTex, vec2(matcap.x, 1.0 - matcap.y)).rgb;\n}\nvec2 UVTrans(vec2 uv,float mipLv)\n{\n  mipLv = floor(mipLv);\n  float x_offset = 0.0;\n  float curSize_x = pow(2.0, 7.0 -mipLv);\n  for(float i = 0.0; i<10.0; ++i)\n  {\n    if(i>=mipLv)break;\n    x_offset = x_offset + pow(2.0, 7.0 - i);\n  }\n  return vec2((x_offset + uv.x * curSize_x)/256.0, uv.y * ((curSize_x/2.0)/64.0));\n}\nvec4 MipSample(sampler2D image, vec2 uv, float mipLv)\n{\n  vec2 uv_floor = UVTrans(uv, floor(mipLv));\n  vec2 uv_ceil = UVTrans(uv, ceil(mipLv));\n  return mix(texture(image, vec2(uv_floor.x,1.0 - uv_floor.y)).rgba, texture(image, vec2(uv_ceil.x,1.0 - uv_ceil.y)).rgba, fract(mipLv));\n}\nvec3 UnpackScaleNormal(vec3 normalMapSample, float scale)\n{\n  vec3 normalT;\n  normalT.x = 2.0 * normalMapSample.x - 1.0;\n  normalT.y = 1.0 - 2.0 * normalMapSample.y;\n  normalT.xy *= scale;\n  normalT.z = 2.0*normalMapSample.z - 1.0;\n  return normalT;\n}\nvec3 WorldNormalVector(vec3 packedNormal, vec3 unitNormal, vec3 tangent,vec3 binormal)\n{\n  vec3 N = normalize(unitNormal);\n  vec3 T = normalize(tangent);\n  vec3 B = normalize(binormal);\n  mat3 TBN = mat3(T, B, N);\n  vec3 bumpedNormal = TBN*packedNormal;\n  return bumpedNormal;\n}\nvec3 NormalMapCombine(vec3 n1, vec3 n2)\n{\n  #if _COMBINEOPTION_UNITYBLENDING\n    mat3 nBasis = mat3(\n      vec3(n1.z, n1.y, -n1.x),\n      vec3(n1.x, n1.z, -n1.y),\n      vec3(n1.x, n1.y,  n1.z));\n    vec3 r = normalize(n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);\n    return r;\n  #endif\n  return n1;\n}\nvec3 ShiftTangent(vec3 T,vec3 N,float shift)\n{\n  return normalize(N*shift+vec3(-T.x,T.y,T.z));\n}\nfloat StrandSpecular(vec3 H,vec3 T,float exponent)\n{\n  float dotTH = dot(T,H);\n  return smoothstep(-1.0,0.0,dotTH)*pow(sqrt(1.0-pow(dotTH,2.0)),exponent);\n}\nvec3 StrandHairSpecular(float shift,vec3 normal,vec3 tangent,vec3 halfVector,float exponent,vec3 fuzzColor)\n{\n  return StrandSpecular(halfVector,ShiftTangent(normalize(tangent),normal,shift),exponent)*fuzzColor;\n}\nvec4 frag ()\n{\n  vec3 worldViewDir = UnitySafeNormalize(v_viewDir);\n  vec3 worldSpaceLightDir = UnitySafeNormalize(-cc_mainLitDir.xyz);\n  vec3 normal_final = vec3(0.0);\n  vec3 normal_map_rgb_base = vec3(0.5, 0.5, 1.0);\n  vec3 normal_map_rgb_detail = vec3(0.5, 0.5, 1.0);\n  #if _USENORMALMAP_ON\n    normal_map_rgb_base = texture(u_normal_map, v_Texcoord0).rgb;\n  #endif\n  normal_map_rgb_base = UnpackScaleNormal(normal_map_rgb_base, u_normal_scale);\n  #if _USEDETAILNORMALMAP_ON\n    normal_map_rgb_detail = texture(u_detail_normal_map, v_Texcoord0*u_detail_normal_map_st.xy + u_detail_normal_map_st.zw).rgb;\n  #endif\n  normal_map_rgb_detail = UnpackScaleNormal(normal_map_rgb_detail, u_detail_normal_scale);\n  normal_final = NormalMapCombine(normal_map_rgb_base, normal_map_rgb_detail);\n  vec3 worldNormal = UnitySafeNormalize(WorldNormalVector(normal_final,v_Normal.xyz,v_Tangent.xyz,v_Binormal.xyz));\n  #if LinearMode\n    vec4 unity_color = vec4(0.04, 0.04, 0.04, 0.96);\n  #else\n    vec4 unity_color = vec4(0.22, 0.22, 0.22, 0.78);\n  #endif\n  float ao_r = 1.0;\n  #if _USEAOMAP_ON\n    ao_r = texture(u_ao_map, v_Texcoord0).r;\n  #endif\n  ao_r = mix(1.0, ao_r, u_ao_intense);\n  vec4 albedo_rgba = vec4(1.0);\n  #if _USEALBEDOMAP_ON\n    albedo_rgba = texture(u_albedo_map, v_Texcoord0);\n  #endif\n  vec3 albedo_rgb = albedo_rgba.rgb;\n  vec4 dye_rgba = vec4(0.0);\n  #if _USEDYEMAP_ON\n    dye_rgba = texture(u_dye_map, v_Texcoord0);\n  #endif\n  albedo_rgb = mix(mix(u_middle_dye_color,u_top_dye_color,dye_rgba.y),u_bottom_dye_color,dye_rgba.x).xyz*albedo_rgb;\n  vec4 specular_map_rgba = vec4(0.0, 0.0, 0.0, 1.0);\n  #if _USESPECULARMAP_ON\n    specular_map_rgba = texture(u_specular_map, v_Texcoord0);\n  #endif\n  vec3 metallic_rgb = vec3(0.5, 0.5, 0.5);\n  #if _USEMETALLICMAP_ON\n    metallic_rgb = texture(u_metallic_map, v_Texcoord0).rgb;\n  #endif\n  float metallic = 0.0;\n  float gloss = 0.0;\n  float perceptualRoughness = 0.0;\n  float roughness = 0.0;\n  vec3 specularColor = vec3(0.0);\n  float oneMinusReflectivity = 0.0;\n  vec3 diffuseColor = vec3(0.0);\n  #if _TOOGLEPBRPIPELINE_METALLICSIMPLE\n    metallic = u_metallic;\n    gloss = u_glossness;\n    specularColor = mix(unity_color.xyz, albedo_rgb, metallic);\n    oneMinusReflectivity = unity_color.w * (1.0 - metallic);\n    diffuseColor = vec3(oneMinusReflectivity) * albedo_rgb;\n  #endif\n  #if _TOOGLEPBRPIPELINE_METALLICIMAGE\n    metallic = metallic_rgb.r;\n    gloss = metallic_rgb.g;\n    specularColor = mix(unity_color.xyz, albedo_rgb, metallic);\n    oneMinusReflectivity = unity_color.w * (1.0 - metallic);\n    diffuseColor = vec3(oneMinusReflectivity) * albedo_rgb;\n  #endif\n  #if _TOOGLEPBRPIPELINE_SPECULARSIMPLE\n    metallic = 0.0;\n    gloss = u_glossness;\n    specularColor = u_specular_color.rgb;\n    oneMinusReflectivity = 1.0 - max(max(specularColor.x, specularColor.y), specularColor.z);\n    diffuseColor = (vec3(1.0, 1.0, 1.0) - specularColor) * albedo_rgb;\n  #endif\n  #if _TOOGLEPBRPIPELINE_SPECULARIMAGE\n    metallic = 0.0;\n    gloss = specular_map_rgba.a;\n    specularColor = specular_map_rgba.xyz;\n    oneMinusReflectivity = 1.0 - max(max(specularColor.x, specularColor.y), specularColor.z);\n    diffuseColor = (vec3(1.0, 1.0, 1.0) - specularColor) * albedo_rgb;\n  #endif\n  perceptualRoughness = 1.0 - gloss;\n  roughness = max(perceptualRoughness * perceptualRoughness, 0.002);\n  vec3 blinnPhongHalfVector = normalize(worldViewDir + worldSpaceLightDir);\n  float nDotL = clamp(dot(worldNormal, worldSpaceLightDir), 0.0, 1.0);\n  float lDotH = clamp(dot(worldSpaceLightDir, blinnPhongHalfVector), 0.0, 1.0);\n  float nDotV = abs(dot(worldNormal, worldViewDir));\n  vec3 attenColor = vec3(0.7, 0.69,0.67);\n  float halfLambert =  dot(worldNormal, worldSpaceLightDir) *0.5 + 0.5;\n  vec3 bloodColor =vec3(0.0);\n  #if _TOGGLEDIFFUSERAMP_NONE\n    bloodColor = vec3(nDotL);\n  #endif\n  #if _TOGGLEDIFFUSERAMP_OLDLUT\n    #if _USESSSMAP_ON\n      bloodColor = texture(u_sss_map, vec2(halfLambert, 1.0 - u_bloodValue)).rgb;\n    #endif\n  #endif\n  #if _TOGGLEDIFFUSERAMP_DIFFUSERAMP\n    bloodColor = DiffuseRampToon(halfLambert).xyz;\n  #endif\n  vec3 indirectDiffuse =vec3(0.0);\n  #if _USEINDIRECTDIFFUSEMAP_ON\n    indirectDiffuse = MatCap(u_indirect_diffuse_map, worldNormal) * ao_r;\n  #endif\n  float specular_temp1 = 0.0;\n  if(specularColor != vec3(0.0, 0.0,0.0))\n  {\n    specular_temp1 = 1.0;\n  }\n  #if LinearMode\n    float surfaceReduction = 1.0 / (roughness * roughness + 1.0);\n  #else\n    float surfaceReduction = 1.0 - roughness * perceptualRoughness * 0.28;\n  #endif\n  vec3 direction = reflect(-worldViewDir, worldNormal);\n  direction = vec3(-direction.x,direction.y,direction.z);\n  direction = normalize(direction);\n  vec2 indirect_specular_uv = CyLindricalUvMap(direction);\n  vec3 indirect_specular_rgb = vec3(0.5);\n  indirect_specular_uv = vec2(indirect_specular_uv.x, indirect_specular_uv.y);\n  #if _USEINDIRECTSPECULARMAP_ON\n    indirect_specular_rgb = MipSample(u_indirect_specular_map, indirect_specular_uv, MipLevel(perceptualRoughness) + u_miplv_offset).rgb;\n  #endif\n  indirect_specular_rgb = indirect_specular_rgb * u_m_factor;\n  vec3 indirectSpecular = FresnelLerp(specularColor, clamp(gloss + (1.0 - oneMinusReflectivity), 0.0, 1.0), nDotV) * surfaceReduction * indirect_specular_rgb;\n  vec3 hairShiftRgb = vec3(0.5,0.5,0.5);\n  #if _USEHAIRSHIFTMAP_ON\n    hairShiftRgb = texture(u_hair_shift_map, v_Texcoord0).rgb;\n  #endif\n  vec3 tangent_temp = vec3(0.0);\n  #if _TANGENTDIRECTION_BITANGENT\n    tangent_temp = WorldNormalVector(vec3(0.0,-1.0,0.0),v_Normal.xyz,v_Tangent.xyz,v_Binormal.xyz);\n  #endif\n  #if _TANGENTDIRECTION_TANGENT\n    tangent_temp = WorldNormalVector(vec3(1.0,0.0,0.0),v_Normal.xyz,v_Tangent.xyz,v_Binormal.xyz);\n  #endif\n  vec3 specular = indirectSpecular+dye_rgba.a * (StrandHairSpecular(hairShiftRgb.x - 0.5 + u_primary_shift,worldNormal,tangent_temp,blinnPhongHalfVector,u_primary_exponent,u_primary_color.xyz)+StrandHairSpecular(hairShiftRgb.y - 0.5 + u_secondary_shift,worldNormal,tangent_temp,blinnPhongHalfVector,u_secondary_exponent,u_secondary_color.xyz));\n  vec3 tempFinalCol =  (indirectDiffuse + bloodColor * DisneyDiffuse(nDotV, nDotL, lDotH, perceptualRoughness) * attenColor) * diffuseColor + specular;\n  vec4 finalCol = vec4(0.0);\n  finalCol.rgb = tempFinalCol;\n  finalCol.a = albedo_rgba.a;\n  return finalCol;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n   uniform vec4 u_TilingOffset;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nmat4 matWorld;\nmat4 matWorldIT;\nvec4 TransformObjectToWorld(vec4 localPos)\n{\n    vec4 wsPos = matWorld * localPos;\n    return wsPos;\n}\nvec4 TransformWorldToHClip(vec4 wsPos)\n{\n    return cc_matViewProj* wsPos;\n}\nvec3 TransformObjectToWorldDir(vec3 localDir)\n{\n    vec3 wsDir = normalize((matWorld * vec4(localDir, 0.0)).xyz);\n    return wsDir;\n}\nvec3 TransformObjectToWorldNormal(vec3 localNormal)\n{\n    vec3 wsNormal = normalize((matWorldIT * vec4(localNormal, 0.0)).xyz);\n    return wsNormal;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    varying vec3 v_luv;\n    void CCLightingMapCaclUV()\n    {\n    #if !USE_INSTANCING\n      v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n      v_luv.z = cc_lightingMapUVParam.w;\n    #else\n      v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n      v_luv.z = a_lightingMapUVParam.w;\n    #endif\n    }\n#endif\nattribute vec4 a_Color;\nvarying lowp vec4 v_Color;\nvarying vec2 v_Texcoord0;\nvarying mediump vec3 v_worldPos;\nvarying mediump vec3 v_viewDir;\nvarying mediump vec4 v_Tangent;\nvarying mediump vec4 v_Normal;\nvarying mediump vec4 v_Binormal;\n#if CC_RECEIVE_SHADOW\n    varying mediump vec2 v_shadowBias;\n#endif\nvec4 hairLitVert()\n{\n    StandardVertInput In; CCVertInput(In); CCGetWorldMatrixFull(matWorld, matWorldIT);\n    vec4 wsPos=TransformObjectToWorld(In.position);\n    v_worldPos = wsPos.xyz;\n    v_Normal.xyz=TransformObjectToWorldNormal(In.normal);\n    v_Tangent.xyz=TransformObjectToWorldDir(In.tangent.xyz);\n    v_Binormal.xyz=cross(v_Normal.xyz,v_Tangent.xyz)*In.tangent.w;\n    v_Texcoord0 = a_texCoord * u_TilingOffset.xy + u_TilingOffset.zw;\n    v_viewDir = cc_cameraPos.xyz - v_worldPos;\n    #if COLOR && ENABLEVERTEXCOLOR\n        v_Color = a_Color;\n    #endif\n    #if CC_RECEIVE_SHADOW\n      v_shadowBias = CCGetShadowBias();\n    #endif\n    #if SAMPLE_FROM_RT\n      v_Texcoord0 = cc_cameraPos.w > 1.0 ? vec2(v_Texcoord0.x, 1.0 - v_Texcoord0.y) : v_Texcoord0;\n    #endif\n    CC_TRANSFER_FOG(wsPos);\n    v_shadowPos = cc_matLightViewProj * wsPos;\n    #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n      CCLightingMapCaclUV();\n    #endif\n    return TransformWorldToHClip(wsPos);\n}\nvec4 vert ()\n{\n  return hairLitVert();\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 u_bottom_dye_color;\n   uniform vec4 u_top_dye_color;\n   uniform vec4 u_middle_dye_color;\n   uniform vec4 u_primary_color;\n   uniform vec4 u_secondary_color;\n   uniform vec4 u_detail_normal_map_st;\n   uniform vec4 u_specular_color;\n   uniform vec4 u_tintcolor_base;\n   uniform vec4 u_tintcolor_high;\n   uniform vec4 u_tintcolor_mid;\n   uniform vec4 u_tintcolor_low;\n   uniform float u_primary_shift;\n   uniform float u_primary_exponent;\n   uniform float u_secondary_shift;\n   uniform float u_secondary_exponent;\n   uniform float u_ao_intense;\n   uniform float u_normal_scale;\n   uniform float u_detail_normal_scale;\n   uniform float u_metallic;\n   uniform float u_glossness;\n   uniform float u_bloodValue;\n   uniform float u_diffuseRampToon_v;\n   uniform float u_diffuseRampToon_u_high;\n   uniform float u_diffuseRampToon_u_mid;\n   uniform float u_diffuseRampToon_u_low;\n   uniform float u_miplv_offset;\n   uniform float u_m_factor;\nuniform highp mat4 cc_matView;\n  uniform mediump vec4 cc_mainLitDir;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    varying vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n#endif\nvarying lowp vec4 v_Color;\nvarying vec2 v_Texcoord0;\nvarying vec3 v_worldPos;\nvarying mediump vec3 v_viewDir;\nvarying mediump vec4 v_Normal;\nvarying mediump vec4 v_Tangent;\nvarying mediump vec4 v_Binormal;\nuniform sampler2D u_albedo_map;\n#if _USEDYEMAP_ON\n  uniform sampler2D u_dye_map;\n#endif\n#if _USEHAIRSHIFTMAP_ON\n  uniform sampler2D u_hair_shift_map;\n#endif\n#if _USEAOMAP_ON\n  uniform sampler2D u_ao_map;\n#endif\n#if _USENORMALMAP_ON\n  uniform sampler2D u_normal_map;\n#endif\n#if _USEDETAILNORMALMAP_ON\n  uniform sampler2D u_detail_normal_map;\n#endif\n#if _USEMETALLICMAP_ON\n  uniform sampler2D u_metallic_map;\n#endif\n#if _USESSSMAP_ON\n  uniform sampler2D u_sss_map;\n#endif\n#if _USESPECULARMAP_ON\n  uniform sampler2D u_specular_map;\n#endif\n#if _USEDIFFUSERAMPMAP_ON\n  uniform sampler2D u_diffuseRamp_map;\n#endif\n#if _USEINDIRECTDIFFUSEMAP_ON\n  uniform sampler2D u_indirect_diffuse_map;\n#endif\n#if _USEINDIRECTSPECULARMAP_ON\n  uniform sampler2D u_indirect_specular_map;\n#endif\nvec2 CyLindricalUvMap(vec3 direction)\n{\n  direction = normalize(direction);\n  float x = 0.75 - atan(direction.z, direction.x)/PI/2.0;\n  if(x>1.0)\n  {\n    x = x - 1.0;\n  }\n  return vec2(x, 1.0 - acos(direction.y)/PI);\n}\nfloat MipLevel(float roughness)\n{\n  return (1.7 - roughness * 0.7) * roughness * 6.0;\n}\nvec3 FresnelLerp(vec3 specularColor, float grazingTerm, float nDotV)\n{\n  return mix(specularColor, vec3(grazingTerm), pow( 1.0 - nDotV, 5.0));\n}\nfloat DisneyDiffuse(float nDotV,float nDotL,float lDotH,float perceptualRoughness)\n{\n  float fd90 = lDotH * lDotH * perceptualRoughness * 2.0 + 0.5;\n  return ((fd90 - 1.0) * pow(1.0 - nDotL, 5.0) + 1.0) * ((fd90 - 1.0) * pow(1.0 - nDotV, 5.0) + 1.0);\n}\nvec2 HalfLambertOffset(float uOffset, float vOffet,float halfLambert)\n{\n  return vec2(clamp(uOffset+halfLambert, 0.0, 1.0), vOffet);\n}\nvec4 DiffuseRampToon(float halfLambert)\n{\n  float rampHightChannel = 1.0;\n  #if _USEDIFFUSERAMPMAP_ON\n    vec2 uv_rampHightChannel = HalfLambertOffset(u_diffuseRampToon_u_high, u_diffuseRampToon_v, halfLambert);\n    uv_rampHightChannel = vec2(uv_rampHightChannel.x, uv_rampHightChannel.y);\n    rampHightChannel = texture2D(u_diffuseRamp_map, uv_rampHightChannel).r;\n  #endif\n  float rampMidChannel = 1.0;\n  #if _USEDIFFUSERAMPMAP_ON\n    vec2 uv_rampMidChannel = HalfLambertOffset(u_diffuseRampToon_u_mid, u_diffuseRampToon_v, halfLambert);\n    uv_rampMidChannel = vec2(uv_rampMidChannel.x, uv_rampMidChannel.y);\n    rampMidChannel = texture2D(u_diffuseRamp_map, uv_rampMidChannel).g;\n  #endif\n  float rampLowChannel = 1.0;\n  #if _USEDIFFUSERAMPMAP_ON\n    vec2 uv_rampLowChannel = HalfLambertOffset(u_diffuseRampToon_u_low, u_diffuseRampToon_v, halfLambert);\n    uv_rampLowChannel = vec2(uv_rampLowChannel.x, uv_rampLowChannel.y);\n    rampLowChannel = texture2D(u_diffuseRamp_map, uv_rampLowChannel).b;\n  #endif\n  float tintHighAlpha = u_tintcolor_high.a * rampHightChannel;\n  float tintMidAlpha = u_tintcolor_mid.a * rampMidChannel;\n  float tintLowAlpha = u_tintcolor_low.a * rampLowChannel;\n  vec3 rgb = mix(mix(mix(u_tintcolor_base.rgb, u_tintcolor_high.rgb, tintHighAlpha), u_tintcolor_mid.rgb, tintMidAlpha), u_tintcolor_low.rgb, tintLowAlpha);\n  return vec4(rgb.xyz, tintHighAlpha + tintMidAlpha + tintLowAlpha);\n}\nvec3 UnitySafeNormalize(vec3 inVec)\n{\n    return inVec * inversesqrt(max(0.001, dot(inVec, inVec)));\n}\nvec3 MatCap(sampler2D inTex,vec3 inNormal)\n{\n  vec2 matcap = (cc_matView * vec4(inNormal, 0.0)*0.45+0.5).xy;\n  return texture2D(inTex, vec2(matcap.x, 1.0 - matcap.y)).rgb;\n}\nvec2 UVTrans(vec2 uv,float mipLv)\n{\n  mipLv = floor(mipLv);\n  float x_offset = 0.0;\n  float curSize_x = pow(2.0, 7.0 -mipLv);\n  for(float i = 0.0; i<10.0; ++i)\n  {\n    if(i>=mipLv)break;\n    x_offset = x_offset + pow(2.0, 7.0 - i);\n  }\n  return vec2((x_offset + uv.x * curSize_x)/256.0, uv.y * ((curSize_x/2.0)/64.0));\n}\nvec4 MipSample(sampler2D image, vec2 uv, float mipLv)\n{\n  vec2 uv_floor = UVTrans(uv, floor(mipLv));\n  vec2 uv_ceil = UVTrans(uv, ceil(mipLv));\n  return mix(texture2D(image, vec2(uv_floor.x,1.0 - uv_floor.y)).rgba, texture2D(image, vec2(uv_ceil.x,1.0 - uv_ceil.y)).rgba, fract(mipLv));\n}\nvec3 UnpackScaleNormal(vec3 normalMapSample, float scale)\n{\n  vec3 normalT;\n  normalT.x = 2.0 * normalMapSample.x - 1.0;\n  normalT.y = 1.0 - 2.0 * normalMapSample.y;\n  normalT.xy *= scale;\n  normalT.z = 2.0*normalMapSample.z - 1.0;\n  return normalT;\n}\nvec3 WorldNormalVector(vec3 packedNormal, vec3 unitNormal, vec3 tangent,vec3 binormal)\n{\n  vec3 N = normalize(unitNormal);\n  vec3 T = normalize(tangent);\n  vec3 B = normalize(binormal);\n  mat3 TBN = mat3(T, B, N);\n  vec3 bumpedNormal = TBN*packedNormal;\n  return bumpedNormal;\n}\nvec3 NormalMapCombine(vec3 n1, vec3 n2)\n{\n  #if _COMBINEOPTION_UNITYBLENDING\n    mat3 nBasis = mat3(\n      vec3(n1.z, n1.y, -n1.x),\n      vec3(n1.x, n1.z, -n1.y),\n      vec3(n1.x, n1.y,  n1.z));\n    vec3 r = normalize(n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);\n    return r;\n  #endif\n  return n1;\n}\nvec3 ShiftTangent(vec3 T,vec3 N,float shift)\n{\n  return normalize(N*shift+vec3(-T.x,T.y,T.z));\n}\nfloat StrandSpecular(vec3 H,vec3 T,float exponent)\n{\n  float dotTH = dot(T,H);\n  return smoothstep(-1.0,0.0,dotTH)*pow(sqrt(1.0-pow(dotTH,2.0)),exponent);\n}\nvec3 StrandHairSpecular(float shift,vec3 normal,vec3 tangent,vec3 halfVector,float exponent,vec3 fuzzColor)\n{\n  return StrandSpecular(halfVector,ShiftTangent(normalize(tangent),normal,shift),exponent)*fuzzColor;\n}\nvec4 frag ()\n{\n  vec3 worldViewDir = UnitySafeNormalize(v_viewDir);\n  vec3 worldSpaceLightDir = UnitySafeNormalize(-cc_mainLitDir.xyz);\n  vec3 normal_final = vec3(0.0);\n  vec3 normal_map_rgb_base = vec3(0.5, 0.5, 1.0);\n  vec3 normal_map_rgb_detail = vec3(0.5, 0.5, 1.0);\n  #if _USENORMALMAP_ON\n    normal_map_rgb_base = texture2D(u_normal_map, v_Texcoord0).rgb;\n  #endif\n  normal_map_rgb_base = UnpackScaleNormal(normal_map_rgb_base, u_normal_scale);\n  #if _USEDETAILNORMALMAP_ON\n    normal_map_rgb_detail = texture2D(u_detail_normal_map, v_Texcoord0*u_detail_normal_map_st.xy + u_detail_normal_map_st.zw).rgb;\n  #endif\n  normal_map_rgb_detail = UnpackScaleNormal(normal_map_rgb_detail, u_detail_normal_scale);\n  normal_final = NormalMapCombine(normal_map_rgb_base, normal_map_rgb_detail);\n  vec3 worldNormal = UnitySafeNormalize(WorldNormalVector(normal_final,v_Normal.xyz,v_Tangent.xyz,v_Binormal.xyz));\n  #if LinearMode\n    vec4 unity_color = vec4(0.04, 0.04, 0.04, 0.96);\n  #else\n    vec4 unity_color = vec4(0.22, 0.22, 0.22, 0.78);\n  #endif\n  float ao_r = 1.0;\n  #if _USEAOMAP_ON\n    ao_r = texture2D(u_ao_map, v_Texcoord0).r;\n  #endif\n  ao_r = mix(1.0, ao_r, u_ao_intense);\n  vec4 albedo_rgba = vec4(1.0);\n  #if _USEALBEDOMAP_ON\n    albedo_rgba = texture2D(u_albedo_map, v_Texcoord0);\n  #endif\n  vec3 albedo_rgb = albedo_rgba.rgb;\n  vec4 dye_rgba = vec4(0.0);\n  #if _USEDYEMAP_ON\n    dye_rgba = texture2D(u_dye_map, v_Texcoord0);\n  #endif\n  albedo_rgb = mix(mix(u_middle_dye_color,u_top_dye_color,dye_rgba.y),u_bottom_dye_color,dye_rgba.x).xyz*albedo_rgb;\n  vec4 specular_map_rgba = vec4(0.0, 0.0, 0.0, 1.0);\n  #if _USESPECULARMAP_ON\n    specular_map_rgba = texture2D(u_specular_map, v_Texcoord0);\n  #endif\n  vec3 metallic_rgb = vec3(0.5, 0.5, 0.5);\n  #if _USEMETALLICMAP_ON\n    metallic_rgb = texture2D(u_metallic_map, v_Texcoord0).rgb;\n  #endif\n  float metallic = 0.0;\n  float gloss = 0.0;\n  float perceptualRoughness = 0.0;\n  float roughness = 0.0;\n  vec3 specularColor = vec3(0.0);\n  float oneMinusReflectivity = 0.0;\n  vec3 diffuseColor = vec3(0.0);\n  #if _TOOGLEPBRPIPELINE_METALLICSIMPLE\n    metallic = u_metallic;\n    gloss = u_glossness;\n    specularColor = mix(unity_color.xyz, albedo_rgb, metallic);\n    oneMinusReflectivity = unity_color.w * (1.0 - metallic);\n    diffuseColor = vec3(oneMinusReflectivity) * albedo_rgb;\n  #endif\n  #if _TOOGLEPBRPIPELINE_METALLICIMAGE\n    metallic = metallic_rgb.r;\n    gloss = metallic_rgb.g;\n    specularColor = mix(unity_color.xyz, albedo_rgb, metallic);\n    oneMinusReflectivity = unity_color.w * (1.0 - metallic);\n    diffuseColor = vec3(oneMinusReflectivity) * albedo_rgb;\n  #endif\n  #if _TOOGLEPBRPIPELINE_SPECULARSIMPLE\n    metallic = 0.0;\n    gloss = u_glossness;\n    specularColor = u_specular_color.rgb;\n    oneMinusReflectivity = 1.0 - max(max(specularColor.x, specularColor.y), specularColor.z);\n    diffuseColor = (vec3(1.0, 1.0, 1.0) - specularColor) * albedo_rgb;\n  #endif\n  #if _TOOGLEPBRPIPELINE_SPECULARIMAGE\n    metallic = 0.0;\n    gloss = specular_map_rgba.a;\n    specularColor = specular_map_rgba.xyz;\n    oneMinusReflectivity = 1.0 - max(max(specularColor.x, specularColor.y), specularColor.z);\n    diffuseColor = (vec3(1.0, 1.0, 1.0) - specularColor) * albedo_rgb;\n  #endif\n  perceptualRoughness = 1.0 - gloss;\n  roughness = max(perceptualRoughness * perceptualRoughness, 0.002);\n  vec3 blinnPhongHalfVector = normalize(worldViewDir + worldSpaceLightDir);\n  float nDotL = clamp(dot(worldNormal, worldSpaceLightDir), 0.0, 1.0);\n  float lDotH = clamp(dot(worldSpaceLightDir, blinnPhongHalfVector), 0.0, 1.0);\n  float nDotV = abs(dot(worldNormal, worldViewDir));\n  vec3 attenColor = vec3(0.7, 0.69,0.67);\n  float halfLambert =  dot(worldNormal, worldSpaceLightDir) *0.5 + 0.5;\n  vec3 bloodColor =vec3(0.0);\n  #if _TOGGLEDIFFUSERAMP_NONE\n    bloodColor = vec3(nDotL);\n  #endif\n  #if _TOGGLEDIFFUSERAMP_OLDLUT\n    #if _USESSSMAP_ON\n      bloodColor = texture2D(u_sss_map, vec2(halfLambert, 1.0 - u_bloodValue)).rgb;\n    #endif\n  #endif\n  #if _TOGGLEDIFFUSERAMP_DIFFUSERAMP\n    bloodColor = DiffuseRampToon(halfLambert).xyz;\n  #endif\n  vec3 indirectDiffuse =vec3(0.0);\n  #if _USEINDIRECTDIFFUSEMAP_ON\n    indirectDiffuse = MatCap(u_indirect_diffuse_map, worldNormal) * ao_r;\n  #endif\n  float specular_temp1 = 0.0;\n  if(specularColor != vec3(0.0, 0.0,0.0))\n  {\n    specular_temp1 = 1.0;\n  }\n  #if LinearMode\n    float surfaceReduction = 1.0 / (roughness * roughness + 1.0);\n  #else\n    float surfaceReduction = 1.0 - roughness * perceptualRoughness * 0.28;\n  #endif\n  vec3 direction = reflect(-worldViewDir, worldNormal);\n  direction = vec3(-direction.x,direction.y,direction.z);\n  direction = normalize(direction);\n  vec2 indirect_specular_uv = CyLindricalUvMap(direction);\n  vec3 indirect_specular_rgb = vec3(0.5);\n  indirect_specular_uv = vec2(indirect_specular_uv.x, indirect_specular_uv.y);\n  #if _USEINDIRECTSPECULARMAP_ON\n    indirect_specular_rgb = MipSample(u_indirect_specular_map, indirect_specular_uv, MipLevel(perceptualRoughness) + u_miplv_offset).rgb;\n  #endif\n  indirect_specular_rgb = indirect_specular_rgb * u_m_factor;\n  vec3 indirectSpecular = FresnelLerp(specularColor, clamp(gloss + (1.0 - oneMinusReflectivity), 0.0, 1.0), nDotV) * surfaceReduction * indirect_specular_rgb;\n  vec3 hairShiftRgb = vec3(0.5,0.5,0.5);\n  #if _USEHAIRSHIFTMAP_ON\n    hairShiftRgb = texture2D(u_hair_shift_map, v_Texcoord0).rgb;\n  #endif\n  vec3 tangent_temp = vec3(0.0);\n  #if _TANGENTDIRECTION_BITANGENT\n    tangent_temp = WorldNormalVector(vec3(0.0,-1.0,0.0),v_Normal.xyz,v_Tangent.xyz,v_Binormal.xyz);\n  #endif\n  #if _TANGENTDIRECTION_TANGENT\n    tangent_temp = WorldNormalVector(vec3(1.0,0.0,0.0),v_Normal.xyz,v_Tangent.xyz,v_Binormal.xyz);\n  #endif\n  vec3 specular = indirectSpecular+dye_rgba.a * (StrandHairSpecular(hairShiftRgb.x - 0.5 + u_primary_shift,worldNormal,tangent_temp,blinnPhongHalfVector,u_primary_exponent,u_primary_color.xyz)+StrandHairSpecular(hairShiftRgb.y - 0.5 + u_secondary_shift,worldNormal,tangent_temp,blinnPhongHalfVector,u_secondary_exponent,u_secondary_color.xyz));\n  vec3 tempFinalCol =  (indirectDiffuse + bloodColor * DisneyDiffuse(nDotV, nDotL, lDotH, perceptualRoughness) * attenColor) * diffuseColor + specular;\n  vec4 finalCol = vec4(0.0);\n  finalCol.rgb = tempFinalCol;\n  finalCol.a = albedo_rgba.a;\n  return finalCol;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":157,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":129}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"COLOR","type":"boolean"},{"name":"ENABLEVERTEXCOLOR","type":"boolean"},{"name":"SAMPLE_FROM_RT","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"_USEDYEMAP_ON","type":"boolean"},{"name":"_USEHAIRSHIFTMAP_ON","type":"boolean"},{"name":"_USEAOMAP_ON","type":"boolean"},{"name":"_USENORMALMAP_ON","type":"boolean"},{"name":"_USEDETAILNORMALMAP_ON","type":"boolean"},{"name":"_USEMETALLICMAP_ON","type":"boolean"},{"name":"_USESSSMAP_ON","type":"boolean"},{"name":"_USESPECULARMAP_ON","type":"boolean"},{"name":"_USEDIFFUSERAMPMAP_ON","type":"boolean"},{"name":"_USEINDIRECTDIFFUSEMAP_ON","type":"boolean"},{"name":"_USEINDIRECTSPECULARMAP_ON","type":"boolean"},{"name":"_COMBINEOPTION_UNITYBLENDING","type":"boolean"},{"name":"LinearMode","type":"boolean"},{"name":"_USEALBEDOMAP_ON","type":"boolean"},{"name":"_TOOGLEPBRPIPELINE_METALLICSIMPLE","type":"boolean"},{"name":"_TOOGLEPBRPIPELINE_METALLICIMAGE","type":"boolean"},{"name":"_TOOGLEPBRPIPELINE_SPECULARSIMPLE","type":"boolean"},{"name":"_TOOGLEPBRPIPELINE_SPECULARIMAGE","type":"boolean"},{"name":"_TOGGLEDIFFUSERAMP_NONE","type":"boolean"},{"name":"_TOGGLEDIFFUSERAMP_OLDLUT","type":"boolean"},{"name":"_TOGGLEDIFFUSERAMP_DIFFUSERAMP","type":"boolean"},{"name":"_TANGENTDIRECTION_BITANGENT","type":"boolean"},{"name":"_TANGENTDIRECTION_TANGENT","type":"boolean"}]},{"hash":3156288415,"name":"../sdk/res/mat/hair|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"u_bottom_dye_color","type":16,"count":1},{"name":"u_top_dye_color","type":16,"count":1},{"name":"u_middle_dye_color","type":16,"count":1},{"name":"u_primary_color","type":16,"count":1},{"name":"u_secondary_color","type":16,"count":1},{"name":"u_detail_normal_map_st","type":16,"count":1},{"name":"u_specular_color","type":16,"count":1},{"name":"u_tintcolor_base","type":16,"count":1},{"name":"u_tintcolor_high","type":16,"count":1},{"name":"u_tintcolor_mid","type":16,"count":1},{"name":"u_tintcolor_low","type":16,"count":1},{"name":"u_TilingOffset","type":16,"count":1},{"name":"u_primary_shift","type":13,"count":1},{"name":"u_primary_exponent","type":13,"count":1},{"name":"u_secondary_shift","type":13,"count":1},{"name":"u_secondary_exponent","type":13,"count":1},{"name":"u_ao_intense","type":13,"count":1},{"name":"u_normal_scale","type":13,"count":1},{"name":"u_detail_normal_scale","type":13,"count":1},{"name":"u_metallic","type":13,"count":1},{"name":"u_glossness","type":13,"count":1},{"name":"u_bloodValue","type":13,"count":1},{"name":"u_diffuseRampToon_v","type":13,"count":1},{"name":"u_diffuseRampToon_u_high","type":13,"count":1},{"name":"u_diffuseRampToon_u_mid","type":13,"count":1},{"name":"u_diffuseRampToon_u_low","type":13,"count":1},{"name":"u_miplv_offset","type":13,"count":1},{"name":"u_m_factor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"u_albedo_map","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":15,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"u_bottom_dye_color","type":16,"count":1},{"name":"u_top_dye_color","type":16,"count":1},{"name":"u_middle_dye_color","type":16,"count":1},{"name":"u_primary_color","type":16,"count":1},{"name":"u_secondary_color","type":16,"count":1},{"name":"u_detail_normal_map_st","type":16,"count":1},{"name":"u_specular_color","type":16,"count":1},{"name":"u_tintcolor_base","type":16,"count":1},{"name":"u_tintcolor_high","type":16,"count":1},{"name":"u_tintcolor_mid","type":16,"count":1},{"name":"u_tintcolor_low","type":16,"count":1},{"name":"u_TilingOffset","type":16,"count":1},{"name":"u_primary_shift","type":13,"count":1},{"name":"u_primary_exponent","type":13,"count":1},{"name":"u_secondary_shift","type":13,"count":1},{"name":"u_secondary_exponent","type":13,"count":1},{"name":"u_ao_intense","type":13,"count":1},{"name":"u_normal_scale","type":13,"count":1},{"name":"u_detail_normal_scale","type":13,"count":1},{"name":"u_metallic","type":13,"count":1},{"name":"u_glossness","type":13,"count":1},{"name":"u_bloodValue","type":13,"count":1},{"name":"u_diffuseRampToon_v","type":13,"count":1},{"name":"u_diffuseRampToon_u_high","type":13,"count":1},{"name":"u_diffuseRampToon_u_mid","type":13,"count":1},{"name":"u_diffuseRampToon_u_low","type":13,"count":1},{"name":"u_miplv_offset","type":13,"count":1},{"name":"u_m_factor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"u_albedo_map","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_1","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_2","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_3","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 u_bottom_dye_color;\n  vec4 u_top_dye_color;\n  vec4 u_middle_dye_color;\n  vec4 u_primary_color;\n  vec4 u_secondary_color;\n  vec4 u_detail_normal_map_st;\n  vec4 u_specular_color;\n  vec4 u_tintcolor_base;\n  vec4 u_tintcolor_high;\n  vec4 u_tintcolor_mid;\n  vec4 u_tintcolor_low;\n  vec4 u_TilingOffset;\n  float u_primary_shift;\n  float u_primary_exponent;\n  float u_secondary_shift;\n  float u_secondary_exponent;\n  float u_ao_intense;\n  float u_normal_scale;\n  float u_detail_normal_scale;\n  float u_metallic;\n  float u_glossness;\n  float u_bloodValue;\n  float u_diffuseRampToon_v;\n  float u_diffuseRampToon_u_high;\n  float u_diffuseRampToon_u_mid;\n  float u_diffuseRampToon_u_low;\n  float u_miplv_offset;\n  float u_m_factor;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nout vec2 v_Texcoord0;\nout vec4 v_worldPos;\nout highp vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_Texcoord0 = a_texCoord * u_TilingOffset.xy + u_TilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n    mediump vec4 cc_debug_view_mode;\n    mediump vec4 cc_debug_view_composite_pack_1;\n    mediump vec4 cc_debug_view_composite_pack_2;\n    mediump vec4 cc_debug_view_composite_pack_3;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_surfaceTransform;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nin vec2 v_Texcoord0;\nin vec4 v_worldPos;\nin highp vec2 v_clip_depth;\nuniform sampler2D u_albedo_map;\nvec4 frag ()\n{\n  #if _ALPHA_ALBEDO\n    vec4 baseColor = texture(u_albedo_map, v_Texcoord0);\n    if (baseColor.a < 0.5) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999)\n  {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 u_TilingOffset;\nuniform highp mat4 cc_matLightViewProj;\nvarying vec2 v_Texcoord0;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_Texcoord0 = a_texCoord * u_TilingOffset.xy + u_TilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nvarying vec2 v_Texcoord0;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\nuniform sampler2D u_albedo_map;\nvec4 frag ()\n{\n  #if _ALPHA_ALBEDO\n    vec4 baseColor = texture2D(u_albedo_map, v_Texcoord0);\n    if (baseColor.a < 0.5) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999)\n  {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":72,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":101}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"_ALPHA_ALBEDO","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"../sdk/res/mat/hair|hair-vs:vert|hair-fs:frag","rasterizerState":{"cullMode":2},"blendState":{"targets":[{"blend":false,"blendSrc":1,"blendDst":0,"blendSrcAlpha":1,"blendDstAlpha":0}]},"depthStencilState":{"depthFunc":3,"depthTest":true,"depthWrite":true},"properties":{"u_albedo_map":{"value":"white","type":28},"u_TilingOffset":{"type":16,"value":[1,1,0,0]},"u_dye_map":{"value":"white","type":28},"u_bottom_dye_color":{"linear":true,"type":16,"value":[1,1,1,1]},"u_top_dye_color":{"linear":true,"type":16,"value":[1,1,1,1]},"u_middle_dye_color":{"linear":true,"type":16,"value":[1,1,1,1]},"u_hair_shift_map":{"value":"white","type":28},"u_primary_shift":{"type":13,"value":[1]},"u_primary_exponent":{"type":13,"value":[1]},"u_primary_color":{"linear":true,"type":16,"value":[1,1,1,1]},"u_secondary_shift":{"type":13,"value":[1]},"u_secondary_exponent":{"type":13,"value":[1]},"u_secondary_color":{"linear":true,"type":16,"value":[1,1,1,1]},"u_ao_map":{"value":"white","type":28},"u_ao_intense":{"type":13,"value":[1]},"u_normal_scale":{"type":13,"value":[1]},"u_normal_map":{"value":"normal","type":28},"u_detail_normal_scale":{"type":13,"value":[1]},"u_detail_normal_map":{"value":"normal","type":28},"u_detail_normal_map_st":{"type":16,"value":[1,1,0,0]},"u_metallic":{"type":13,"value":[0]},"u_metallic_map":{"value":"white","type":28},"u_glossness":{"type":13,"value":[0]},"u_bloodValue":{"type":13,"value":[1]},"u_sss_map":{"value":"white","type":28},"u_specular_map":{"value":"white","type":28},"u_specular_color":{"linear":true,"type":16,"value":[1,1,1,1]},"u_diffuseRampToon_v":{"type":13,"value":[1]},"u_diffuseRampToon_u_high":{"type":13,"value":[1]},"u_diffuseRampToon_u_mid":{"type":13,"value":[1]},"u_diffuseRampToon_u_low":{"type":13,"value":[1]},"u_tintcolor_base":{"linear":true,"type":16,"value":[1,1,1,1]},"u_tintcolor_high":{"linear":true,"type":16,"value":[1,1,1,1]},"u_tintcolor_mid":{"linear":true,"type":16,"value":[1,1,1,1]},"u_tintcolor_low":{"linear":true,"type":16,"value":[1,1,1,1]},"u_diffuseRamp_map":{"value":"white","type":28},"u_miplv_offset":{"type":13,"value":[0]},"u_m_factor":{"type":13,"value":[0]},"u_indirect_diffuse_map":{"value":"white","type":28},"u_indirect_specular_map":{"value":"white","type":28}}},{"phase":"shadow-caster","propertyIndex":0,"program":"../sdk/res/mat/hair|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":2},"properties":{"u_TilingOffset":{"type":16,"value":[1,1,0,0]},"u_albedo_map":{"value":"grey","type":28}}}]}]]],0,0,[],[],[]],[[[1,"hair",[{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true}]]],0,0,[0],[0],[0]]]]
